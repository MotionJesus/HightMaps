#include "/Engine/Private/Random.ush"
#include "/Engine/Private/MonteCarlo.ush"
#include "/Engine/Generated/UniformBuffers/Material.ush"

// for MaterialExpressionDepthOfFieldFunction
#include "/Engine/Private/DepthOfFieldCommon.ush"
#include "/Engine/Private/CircleDOFCommon.ush"
#include "/Engine/Private/GlobalDistanceFieldShared.ush"

#if USES_SPEEDTREE
    #include "/Engine/Private/SpeedTreeCommon.ush"
#endif

#define NUM_MATERIAL_TEXCOORDS_VERTEX 1
#define NUM_MATERIAL_TEXCOORDS 1
#define NUM_CUSTOM_VERTEX_INTERPOLATORS 0
#define NUM_TEX_COORD_INTERPOLATORS 1

#ifdef MIN_MATERIAL_TEXCOORDS 
    #include "/Engine/Private/MinMaterialTexCoords.ush"
#endif
 
#if MATERIAL_ATMOSPHERIC_FOG
    #include "/Engine/Private/AtmosphereCommon.ush"
#endif

#include "/Engine/Private/PaniniProjection.ush"

#ifndef USE_DITHERED_LOD_TRANSITION
    #if USE_INSTANCING
        #ifndef USE_DITHERED_LOD_TRANSITION_FOR_INSTANCED
            #error "USE_DITHERED_LOD_TRANSITION_FOR_INSTANCED should have been defined"
        #endif
        #define USE_DITHERED_LOD_TRANSITION USE_DITHERED_LOD_TRANSITION_FOR_INSTANCED
    #else
        #ifndef USE_DITHERED_LOD_TRANSITION_FROM_MATERIAL
            #error "USE_DITHERED_LOD_TRANSITION_FROM_MATERIAL should have been defined"
        #endif
        #define USE_DITHERED_LOD_TRANSITION USE_DITHERED_LOD_TRANSITION_FROM_MATERIAL
    #endif
#endif

#ifndef USE_STENCIL_LOD_DITHER
    #define USE_STENCIL_LOD_DITHER    USE_STENCIL_LOD_DITHER_DEFAULT
#endif


#define PLATFORM_SUPPORTS_EDITOR_SHADERS (!PS4_PROFILE && !XBOXONE_PROFILE && !ESDEFERRED_PROFILE && !SWITCH_PROFILE)


#define USE_EDITOR_SHADERS (PLATFORM_SUPPORTS_EDITOR_SHADERS && USE_DEVELOPMENT_SHADERS)

#define USE_EDITOR_COMPOSITING (USE_EDITOR_SHADERS && EDITOR_PRIMITIVE_MATERIAL)

#define MATERIALBLENDING_ANY_TRANSLUCENT (MATERIALBLENDING_TRANSLUCENT || MATERIALBLENDING_ADDITIVE || MATERIALBLENDING_MODULATE)

#define IS_MESHPARTICLE_FACTORY (PARTICLE_MESH_FACTORY || NIAGARA_MESH_FACTORY)


struct FMaterialParticleParameters
{
    /** Relative time [0-1]. */
    half RelativeTime;
    /** Fade amount due to motion blur. */
    half MotionBlurFade;
    /** Random value per particle [0-1]. */
    half Random;
    /** XYZ: Direction, W: Speed. */
    half4 Velocity;
    /** Per-particle color. */
    half4 Color;
    /** Particle translated world space position and size(radius). */
    float4 TranslatedWorldPositionAndSize;
    /** Macro UV scale and bias. */
    half4 MacroUV;
    /** Dynamic parameter used by particle systems. */
    half4 DynamicParameter;
    /** mesh particle orientation */
    float4x4 LocalToWorld;

#if USE_PARTICLE_SUBUVS
    /** SubUV texture coordinates*/
    MaterialFloat2 SubUVCoords[2];
    /** SubUV interpolation value*/
    MaterialFloat SubUVLerp;
#endif

    /** The size of the particle. */
    float2 Size;
};

float4 GetDynamicParameter(FMaterialParticleParameters Parameters, float4 Default)
{
    #if PARTICLE_FACTORY
    return Parameters.DynamicParameter;
    #else
    return Default;
    #endif
}

/** 
 * Parameters calculated from the pixel material inputs.
 */
struct FPixelMaterialInputs
{
    MaterialFloat3 EmissiveColor;
    MaterialFloat Opacity;
    MaterialFloat OpacityMask;
    MaterialFloat3 BaseColor;
    MaterialFloat Metallic;
    MaterialFloat Specular;
    MaterialFloat Roughness;
    MaterialFloat3 Normal;
    MaterialFloat4 Subsurface;
    MaterialFloat AmbientOcclusion;
    MaterialFloat2 Refraction;
    MaterialFloat PixelDepthOffset;

};

struct FMaterialPixelParameters
{
#if NUM_TEX_COORD_INTERPOLATORS
    float2 TexCoords[NUM_TEX_COORD_INTERPOLATORS];
#endif

    
    half4 VertexColor;
    
    half3 WorldNormal;

    half3 ReflectionVector;

    
    half3 CameraVector;

    
    half3 LightVector;

    float4 SvPosition;
        
    float4 ScreenPosition;

    half UnMirrored;

    half TwoSidedSign;

    half3x3 TangentToWorld;

    float3 AbsoluteWorldPosition;

    float3 WorldPosition_CamRelative;

    float3 WorldPosition_NoOffsets;

    float3 WorldPosition_NoOffsets_CamRelative;

    half3 LightingPositionOffset;

    float AOMaterialMask;

#if LIGHTMAP_UV_ACCESS
    float2    LightmapUVs;
#endif

#if USE_INSTANCING
    half4 PerInstanceParams;
#endif


#if (ES2_PROFILE || ES3_1_PROFILE)
    float4 LayerWeights;
#endif

#if TEX_COORD_SCALE_ANALYSIS    
    FTexCoordScalesParams TexCoordScalesParams;
#endif

#if POST_PROCESS_MATERIAL && (FEATURE_LEVEL <= FEATURE_LEVEL_ES3_1)
    half BackupSceneColorAlpha;
#endif

#if COMPILER_HLSL    
    uint Dummy;
#endif
};

FMaterialPixelParameters MakeInitializedMaterialPixelParameters()
{
    FMaterialPixelParameters MPP;
    MPP = (FMaterialPixelParameters)0;
    MPP.TangentToWorld = float3x3(1,0,0,0,1,0,0,0,1);
    return MPP;
}

struct FMaterialTessellationParameters
{

#if NUM_TEX_COORD_INTERPOLATORS
    float2 TexCoords[NUM_TEX_COORD_INTERPOLATORS];
#endif
    float4 VertexColor;
    float3 WorldPosition;
    float3 TangentToWorldPreScale;
    float3x3 TangentToWorld;
};
struct FMaterialVertexParameters
{

    float3 WorldPosition;
    half3x3 TangentToWorld;
#if USE_INSTANCING
    float4x4 InstanceLocalToWorld;
    float3 InstanceLocalPosition;
    float4 PerInstanceParams;
#elif IS_MESHPARTICLE_FACTORY 
    float4x4 InstanceLocalToWorld;
#endif
    float3 PreSkinnedPosition;
    float3 PreSkinnedNormal;

    half4 VertexColor;
#if NUM_MATERIAL_TEXCOORDS_VERTEX
    float2 TexCoords[NUM_MATERIAL_TEXCOORDS_VERTEX];
    #if (ES2_PROFILE || ES3_1_PROFILE)
    float2 TexCoordOffset;
    #endif
#endif

    FMaterialParticleParameters Particle;
};

float3 GetTranslatedWorldPosition(FMaterialVertexParameters Parameters)
{
    return Parameters.WorldPosition;
}

float3 GetPrevTranslatedWorldPosition(FMaterialVertexParameters Parameters)
{   
    return GetTranslatedWorldPosition(Parameters);
}

float3 GetWorldPosition(FMaterialVertexParameters Parameters)
{
    return GetTranslatedWorldPosition(Parameters) - ResolvedView.PreViewTranslation;
}

float3 GetPrevWorldPosition(FMaterialVertexParameters Parameters)
{
    return GetPrevTranslatedWorldPosition(Parameters) - ResolvedView.PrevPreViewTranslation;
}
float3 GetWorldPosition(FMaterialTessellationParameters Parameters)
{
    return Parameters.WorldPosition;
}

float3 GetTranslatedWorldPosition(FMaterialTessellationParameters Parameters)
{
    return Parameters.WorldPosition + ResolvedView.PreViewTranslation;
}

float3 GetWorldPosition(FMaterialPixelParameters Parameters)
{
    return Parameters.AbsoluteWorldPosition;
}

float3 GetWorldPosition_NoMaterialOffsets(FMaterialPixelParameters Parameters)
{
    return Parameters.WorldPosition_NoOffsets;
}

float3 GetTranslatedWorldPosition(FMaterialPixelParameters Parameters)
{
    return Parameters.WorldPosition_CamRelative;
}

float3 GetTranslatedWorldPosition_NoMaterialOffsets(FMaterialPixelParameters Parameters)
{
    return Parameters.WorldPosition_NoOffsets_CamRelative;
}

float4 GetScreenPosition(FMaterialVertexParameters Parameters)
{
    return mul(float4(Parameters.WorldPosition, 1.0f), ResolvedView.TranslatedWorldToClip);
}

float4 GetScreenPosition(FMaterialPixelParameters Parameters)
{
    return Parameters.ScreenPosition;
}

float2 GetSceneTextureUV(FMaterialVertexParameters Parameters)
{
    return ScreenAlignedPosition(GetScreenPosition(Parameters));
}

float2 GetSceneTextureUV(FMaterialPixelParameters Parameters)
{
    return SvPositionToBufferUV(Parameters.SvPosition);
}

float2 GetViewportUV(FMaterialVertexParameters Parameters)
{
    return BufferUVToViewportUV(GetSceneTextureUV(Parameters));
}

float2 GetViewportUV(FMaterialPixelParameters Parameters)
{
    return SvPositionToViewportUV(Parameters.SvPosition);
}



#if DECAL_PRIMITIVE && NUM_MATERIAL_TEXCOORDS
    float2 ComputeDecalUVFromSvPosition(float4 SvPosition)
    {
        half DeviceZ = LookupDeviceZ(SvPositionToBufferUV(SvPosition));

        SvPosition.z = DeviceZ;

        float4 DecalVector = mul(float4(SvPosition.xyz,1), SvPositionToDecal);
        DecalVector.xyz /= DecalVector.w;
        DecalVector = DecalVector * 0.5f + 0.5f;
        DecalVector.xyz = DecalVector.zyx;
        return DecalVector.xy;
    }

    float2 ComputeDecalDDX(FMaterialPixelParameters Parameters)
    {
        return dot(UvDiffX0, UvDiffX0) < dot(UvDiffX1, UvDiffX1) ? UvDiffX0 : UvDiffX1;
    }

    float2 ComputeDecalDDY(FMaterialPixelParameters Parameters)
    {
        float4 ScreenDeltaY = float4(0, 1, 0, 0);
        float2 UvDiffY0 = Parameters.TexCoords[0] - ComputeDecalUVFromSvPosition(Parameters.SvPosition - ScreenDeltaY);
        float2 UvDiffY1 = ComputeDecalUVFromSvPosition(Parameters.SvPosition + ScreenDeltaY) - Parameters.TexCoords[0];

        return dot(UvDiffY0, UvDiffY0) < dot(UvDiffY1, UvDiffY1) ? UvDiffY0 : UvDiffY1;
    }

    float ComputeDecalMipmapLevel(FMaterialPixelParameters Parameters, float2 TextureSize)
    {
        float2 UvPixelDiffX = ComputeDecalDDX(Parameters) * TextureSize;
        float2 UvPixelDiffY = ComputeDecalDDY(Parameters) * TextureSize;
        float MaxDiff = max(dot(UvPixelDiffX, UvPixelDiffX), dot(UvPixelDiffY, UvPixelDiffY));
        return 0.5 * log2(MaxDiff);
    }
#else
    float2 ComputeDecalDDX(FMaterialPixelParameters Parameters)
    {
        return 0.0f;
    }
    
    float2 ComputeDecalDDY(FMaterialPixelParameters Parameters)
    {
        return 0.0f;
    }

    float ComputeDecalMipmapLevel(FMaterialPixelParameters Parameters, float2 TextureSize)
    {
        return 0.0f;
    }
#endif

#if DECAL_PRIMITIVE
    float3 GetActorWorldPosition()
    {
        return DecalToWorld[3].xyz;
    }
#else
    float3 GetActorWorldPosition()
    {
        return Primitive.ActorWorldPosition;
    }
#endif

#if DECAL_PRIMITIVE
    float DecalLifetimeOpacity()
    {
        return DecalParams.y;
    }
#else
    float DecalLifetimeOpacity()
    {
        return 0.0f;
    }
#endif 
MaterialFloat3 TransformTangentVectorToWorld_PreScaled(FMaterialTessellationParameters Parameters, MaterialFloat3 InTangentVector)
{
#if FEATURE_LEVEL >= FEATURE_LEVEL_SM5
    InTangentVector *= abs( Parameters.TangentToWorldPreScale );    
    return mul(InTangentVector, Parameters.TangentToWorld);
#else
    return TransformTangentVectorToWorld(Parameters.TangentToWorld, InTangentVector);
#endif 
}
MaterialFloat3 TransformTangentVectorToView(FMaterialPixelParameters Parameters, MaterialFloat3 InTangentVector)
{
    return mul(mul(InTangentVector, Parameters.TangentToWorld), (MaterialFloat3x3)ResolvedView.TranslatedWorldToView);
}

MaterialFloat3 TransformLocalVectorToWorld(FMaterialVertexParameters Parameters,MaterialFloat3 InLocalVector)
{
    #if USE_INSTANCING || IS_MESHPARTICLE_FACTORY
        return mul(InLocalVector, (MaterialFloat3x3)Parameters.InstanceLocalToWorld);
    #else
        return mul(InLocalVector, GetLocalToWorld3x3());
    #endif
}

MaterialFloat3 TransformLocalVectorToWorld(FMaterialPixelParameters Parameters,MaterialFloat3 InLocalVector)
{
    return mul(InLocalVector, GetLocalToWorld3x3());
}

#if HAS_PRIMITIVE_UNIFORM_BUFFER

MaterialFloat3 TransformWorldVectorToLocal(MaterialFloat3 InWorldVector)
{
    return mul(InWorldVector, (MaterialFloat3x3)Primitive.WorldToLocal);
}
float3 TransformLocalPositionToWorld(FMaterialPixelParameters Parameters,float3 InLocalPosition)
{
    return mul(float4(InLocalPosition, 1), Primitive.LocalToWorld).xyz;
}
float3 TransformLocalPositionToWorld(FMaterialVertexParameters Parameters,float3 InLocalPosition)
{
    #if USE_INSTANCING || IS_MESHPARTICLE_FACTORY
        return mul(float4(InLocalPosition, 1), Parameters.InstanceLocalToWorld).xyz;
    #else
        return mul(float4(InLocalPosition, 1), Primitive.LocalToWorld).xyz;
    #endif
}

#endif

#if HAS_PRIMITIVE_UNIFORM_BUFFER

/** Return the object's position in world space */
float3 GetObjectWorldPosition(FMaterialPixelParameters Parameters)
{
    return Primitive.ObjectWorldPositionAndRadius.xyz;
}

float3 GetObjectWorldPosition(FMaterialTessellationParameters Parameters)
{
    return Primitive.ObjectWorldPositionAndRadius.xyz;
}

/** Return the object's position in world space. For instanced meshes, this returns the instance position. */
float3 GetObjectWorldPosition(FMaterialVertexParameters Parameters)
{
    #if USE_INSTANCING || IS_MESHPARTICLE_FACTORY
        return Parameters.InstanceLocalToWorld[3].xyz;
    #else
        return Primitive.ObjectWorldPositionAndRadius.xyz;
    #endif
}

#endif

/** Get the per-instance random value when instancing */
float GetPerInstanceRandom(FMaterialVertexParameters Parameters)
{
#if USE_INSTANCING
    return Parameters.PerInstanceParams.x;
#else
    return 0.0;
#endif
}

/** Get the per-instance random value when instancing */
float GetPerInstanceRandom(FMaterialPixelParameters Parameters)
{
#if USE_INSTANCING
    return Parameters.PerInstanceParams.x;
#else
    return 0.0;
#endif
}

/** Get the per-instance fade-out amount when instancing */
float GetPerInstanceFadeAmount(FMaterialPixelParameters Parameters)
{
#if USE_INSTANCING
    return float(Parameters.PerInstanceParams.y);
#else
    return float(1.0);
#endif
}

/** Get the per-instance fade-out amount when instancing */
float GetPerInstanceFadeAmount(FMaterialVertexParameters Parameters)
{
#if USE_INSTANCING
    return float(Parameters.PerInstanceParams.y);
#else
    return float(1.0);
#endif
}
 
MaterialFloat GetDistanceCullFade()
{
    return saturate( View.RealTime * PrimitiveFade.FadeTimeScaleBias.x + PrimitiveFade.FadeTimeScaleBias.y );
}

/** Rotates Position about the given axis by the given angle, in radians, and returns the offset to Position. */
float3 RotateAboutAxis(float4 NormalizedRotationAxisAndAngle, float3 PositionOnAxis, float3 Position)
{
    // Project Position onto the rotation axis and find the closest point on the axis to Position
    float3 ClosestPointOnAxis = PositionOnAxis + NormalizedRotationAxisAndAngle.xyz * dot(NormalizedRotationAxisAndAngle.xyz, Position - PositionOnAxis);
    // Construct orthogonal axes in the plane of the rotation
    float3 UAxis = Position - ClosestPointOnAxis;
    float3 VAxis = cross(NormalizedRotationAxisAndAngle.xyz, UAxis);
    float CosAngle;
    float SinAngle;
    sincos(NormalizedRotationAxisAndAngle.w, SinAngle, CosAngle);
    // Rotate using the orthogonal axes
    float3 R = UAxis * CosAngle + VAxis * SinAngle;
    // Reconstruct the rotated world space position
    float3 RotatedPosition = ClosestPointOnAxis + R;
    // Convert from position to a position offset
    return RotatedPosition - Position;
}

// Material Expression function
float MaterialExpressionDepthOfFieldFunction(float SceneDepth, int FunctionValueIndex)
{
    // tryed switch() but seems that doesn't work

    if(FunctionValueIndex == 0) // TDOF_NearAndFarMask
    {
        return CalcUnfocusedPercentCustomBound(SceneDepth, 1, 1);
    }
    else if(FunctionValueIndex == 1) // TDOF_Near
    {
        return CalcUnfocusedPercentCustomBound(SceneDepth, 1, 0);
    }
    else if(FunctionValueIndex == 2) // TDOF_Far
    {
        return CalcUnfocusedPercentCustomBound(SceneDepth, 0, 1);
    }
    else if(FunctionValueIndex == 3) // TDOF_CircleOfConfusionRadius
    {
        // * 2 to compensate for half res
        return DepthToCoc(SceneDepth) * 2.0f;
    }
    return 0;
}

// TODO convert to LUT
float3 MaterialExpressionBlackBody( float Temp )
{
    float u = ( 0.860117757f + 1.54118254e-4f * Temp + 1.28641212e-7f * Temp*Temp ) / ( 1.0f + 8.42420235e-4f * Temp + 7.08145163e-7f * Temp*Temp );
    float v = ( 0.317398726f + 4.22806245e-5f * Temp + 4.20481691e-8f * Temp*Temp ) / ( 1.0f - 2.89741816e-5f * Temp + 1.61456053e-7f * Temp*Temp );

    float x = 3*u / ( 2*u - 8*v + 4 );
    float y = 2*v / ( 2*u - 8*v + 4 );
    float z = 1 - x - y;

    float Y = 1;
    float X = Y/y * x;
    float Z = Y/y * z;

    float3x3 XYZtoRGB =
    {
         3.2404542, -1.5371385, -0.4985314,
        -0.9692660,  1.8760108,  0.0415560,
         0.0556434, -0.2040259,  1.0572252,
    };

    return mul( XYZtoRGB, float3( X, Y, Z ) ) * pow( 0.0004 * Temp, 4 );
}

float4 MaterialExpressionAtmosphericFog(FMaterialPixelParameters Parameters, float3 AbsoluteWorldPosition)
{
#if MATERIAL_ATMOSPHERIC_FOG
    // WorldPosition default value is Parameters.AbsoluteWorldPosition if not overridden by the user
    float3 ViewVector = AbsoluteWorldPosition - ResolvedView.WorldCameraOrigin;
    float SceneDepth = length(ViewVector);
    return GetAtmosphericFog(ResolvedView.WorldCameraOrigin, ViewVector, SceneDepth, float3(0.f, 0.f, 0.f));
#else
    return float4(0.f, 0.f, 0.f, 0.f);
#endif
}

float3 MaterialExpressionAtmosphericLightVector(FMaterialPixelParameters Parameters)
{
#if MATERIAL_ATMOSPHERIC_FOG
    return View.AtmosphericFogSunDirection;
#else
    return float3(0.f, 0.f, 0.f);
#endif
}

float3 MaterialExpressionAtmosphericLightColor(FMaterialPixelParameters Parameters)
{
#if MATERIAL_ATMOSPHERIC_FOG
    return View.AtmosphericFogSunColor;
#else
    return float3(0.f, 0.f, 0.f);
#endif
}

/**
 * Utility function to unmirror one coordinate value to the other side
 * UnMirrored == 1 if normal
 * UnMirrored == -1 if mirrored
 *
 * Used by most of parameter functions generated via code in this file
 */
MaterialFloat UnMirror( MaterialFloat Coordinate, FMaterialPixelParameters Parameters )
{
    return ((Coordinate)*(Parameters.UnMirrored)*0.5+0.5);
}

/**
 * UnMirror only U
 */
MaterialFloat2 UnMirrorU( MaterialFloat2 UV, FMaterialPixelParameters Parameters )
{
    return MaterialFloat2(UnMirror(UV.x, Parameters), UV.y);
}

/**
 * UnMirror only V
 */
MaterialFloat2 UnMirrorV( MaterialFloat2 UV, FMaterialPixelParameters Parameters )
{
    return MaterialFloat2(UV.x, UnMirror(UV.y, Parameters));
}

/**
 * UnMirror only UV
 */
MaterialFloat2 UnMirrorUV( MaterialFloat2 UV, FMaterialPixelParameters Parameters )
{
    return MaterialFloat2(UnMirror(UV.x, Parameters), UnMirror(UV.y, Parameters));
}

/** 
 * Transforms screen space positions into UVs with [.5, .5] centered on ObjectPostProjectionPosition,
 * And [1, 1] at ObjectPostProjectionPosition + (ObjectRadius, ObjectRadius).
 */
MaterialFloat2 GetParticleMacroUV(FMaterialPixelParameters Parameters)
{
    return (Parameters.ScreenPosition.xy / Parameters.ScreenPosition.w - Parameters.Particle.MacroUV.xy) * Parameters.Particle.MacroUV.zw + MaterialFloat2(.5, .5);
}

MaterialFloat4 ProcessMaterialColorTextureLookup(MaterialFloat4 TextureValue)
{
#if (FEATURE_LEVEL == FEATURE_LEVEL_ES2) // ES2 does not support sRGB sampling
    #if MOBILE_EMULATION
    if( View.MobilePreviewMode > 0.5f)
    {
        // undo HW srgb->lin
        TextureValue.rgb = pow(TextureValue.rgb, 1.0f / 2.2f); // TODO: replace with a more accurate lin -> sRGB conversion.
    }
    #endif
    // sRGB read approximation (in highp if possible)
    float3 LinRGB = TextureValue.rgb;
    LinRGB *= LinRGB; 
    return MaterialFloat4(LinRGB, TextureValue.a);
#endif 
    return TextureValue;
}

MaterialFloat4 ProcessMaterialLinearColorTextureLookup(MaterialFloat4 TextureValue)
{
    return TextureValue;
}

MaterialFloat ProcessMaterialGreyscaleTextureLookup(MaterialFloat TextureValue)
{
#if (FEATURE_LEVEL == FEATURE_LEVEL_ES2) || COMPILER_GLSL_ES3_1 || VULKAN_PROFILE // ES2, OpenGLES3.1, Vulkan3.1 do not support sRGB sampling from R8
    #if MOBILE_EMULATION
    if( View.MobilePreviewMode > 0.5f )
    {
        // undo HW srgb->lin
        TextureValue = pow(TextureValue, 1.0f/2.2f); // TODO: replace with a more accurate lin -> sRGB conversion.
    }
    #endif
    // sRGB read approximation (in highp if possible)
    float LinValue = TextureValue;
    LinValue *= LinValue;
    return MaterialFloat(LinValue);
#endif 
    return TextureValue;
}

MaterialFloat ProcessMaterialLinearGreyscaleTextureLookup(MaterialFloat TextureValue)
{
    return TextureValue;
}

/** Accesses a shared material sampler or falls back if independent samplers are not supported. */
SamplerState GetMaterialSharedSampler(SamplerState TextureSampler, SamplerState SharedSampler)
{
#if SUPPORTS_INDEPENDENT_SAMPLERS
    return SharedSampler;
#else
    // Note: to match behavior on platforms that don't support SUPPORTS_INDEPENDENT_SAMPLERS, 
    // TextureSampler should have been set to the same sampler.  This is not currently done.
    return TextureSampler;
#endif
}

/** Calculate a reflection vector about the specified world space normal. Optionally normalize this normal **/
MaterialFloat3 ReflectionAboutCustomWorldNormal(FMaterialPixelParameters Parameters, MaterialFloat3 WorldNormal, bool bNormalizeInputNormal)
{
    if (bNormalizeInputNormal)
    {
        WorldNormal = normalize(WorldNormal);
    }

    return -Parameters.CameraVector + WorldNormal * dot(WorldNormal, Parameters.CameraVector) * 2.0;
}

#ifndef SPHERICAL_OPACITY_FOR_SHADOW_DEPTHS
#define SPHERICAL_OPACITY_FOR_SHADOW_DEPTHS 0
#endif

/** 
 * Calculates opacity for a billboard particle as if it were a sphere. 
 * Note: Calling this function requires the vertex factory to have been compiled with SPHERICAL_PARTICLE_OPACITY set to 1
 */
float GetSphericalParticleOpacity(FMaterialPixelParameters Parameters, float Density)
{
    float Opacity = 0;

#if PARTICLE_FACTORY || HAS_PRIMITIVE_UNIFORM_BUFFER

#if PARTICLE_FACTORY

    float3 ParticleTranslatedWorldPosition = Parameters.Particle.TranslatedWorldPositionAndSize.xyz;
    float ParticleRadius = max(0.000001f, Parameters.Particle.TranslatedWorldPositionAndSize.w);

#elif HAS_PRIMITIVE_UNIFORM_BUFFER

    // Substitute object attributes if the mesh is not a particle
    // This is mostly useful for previewing materials using spherical opacity in the material editor
    float3 ParticleTranslatedWorldPosition = Primitive.ObjectWorldPositionAndRadius.xyz + ResolvedView.PreViewTranslation.xyz;
    float ParticleRadius = max(0.000001f, Primitive.ObjectWorldPositionAndRadius.w);

#endif

    // Rescale density to make the final opacity independent of the particle radius
    float RescaledDensity = Density / ParticleRadius;

    // Distance from point being shaded to particle center
    float DistanceToParticle = length(Parameters.WorldPosition_NoOffsets_CamRelative - ParticleTranslatedWorldPosition);

    FLATTEN
    if (DistanceToParticle < ParticleRadius) 
    {
        // Distance from point being shaded to the point on the sphere along the view direction
        float HemisphericalDistance = sqrt(ParticleRadius * ParticleRadius - DistanceToParticle * DistanceToParticle);

#if SPHERICAL_OPACITY_FOR_SHADOW_DEPTHS
        // When rendering shadow depths we can't use scene depth or the near plane, just use the distance through the whole sphere
        float DistanceThroughSphere = HemisphericalDistance * 2;
#else
        // Initialize near and far sphere intersection distances
        float NearDistance = Parameters.ScreenPosition.w - HemisphericalDistance;
        float FarDistance = Parameters.ScreenPosition.w + HemisphericalDistance;

        float SceneDepth = CalcSceneDepth(SvPositionToBufferUV(Parameters.SvPosition));
        FarDistance = min(SceneDepth, FarDistance);

        // Take into account opaque objects intersecting the sphere
        float DistanceThroughSphere = FarDistance - NearDistance;
#endif

        // Use the approximation for the extinction line integral from "Spherical Billboards and their Application to Rendering Explosions"
        Opacity = saturate(1 - exp2(-RescaledDensity * (1 - DistanceToParticle / ParticleRadius) * DistanceThroughSphere));

#if !SPHERICAL_OPACITY_FOR_SHADOW_DEPTHS
        // Fade out as the particle approaches the near plane
        Opacity = lerp(0, Opacity, saturate((Parameters.ScreenPosition.w - ParticleRadius - View.NearPlane) / ParticleRadius));
#endif
    }

#endif

    return Opacity;
}

float2 RotateScaleOffsetTexCoords(float2 InTexCoords, float4 InRotationScale, float2 InOffset)
{
    return float2(dot(InTexCoords, InRotationScale.xy), dot(InTexCoords, InRotationScale.zw)) + InOffset;
}

#if USES_SPEEDTREE

/** Vertex offset for SpeedTree wind and LOD */
float3 GetSpeedTreeVertexOffsetInner(FMaterialVertexParameters Parameters, int GeometryType, int WindType, int LODType, float BillboardThreshold, FSpeedTreeData STData) 
{
    #if (NUM_MATERIAL_TEXCOORDS_VERTEX < 6) || IS_MESHPARTICLE_FACTORY
        return float4(0,0,0);
    #endif

    #if USE_INSTANCING
        float3x3 LocalToWorld = (float3x3)Parameters.InstanceLocalToWorld;
        float3 LocalPosition = Parameters.InstanceLocalPosition;

        // skip if this instance is hidden
        if (Parameters.PerInstanceParams.z < 1.f)
        {
            return float3(0,0,0);
        }
    #else
        float3x3 LocalToWorld = (float3x3)Primitive.LocalToWorld;
        float3 LocalPosition = mul(float4(GetWorldPosition(Parameters), 1), Primitive.WorldToLocal).xyz;
    #endif

    float3 TreePos = GetObjectWorldPosition(Parameters);

    // compute LOD by finding screen space size
    float LodInterp = 1.0;
#if !USE_INSTANCING || !USE_DITHERED_LOD_TRANSITION
    if (LODType == SPEEDTREE_LOD_TYPE_SMOOTH) 
    {
        const float ScreenMultiple = 0.5 * max(View.ViewSizeAndInvSize.x * ResolvedView.ViewToClip[0][0],
                                                View.ViewSizeAndInvSize.y * ResolvedView.ViewToClip[1][1]);
        const float ScreenRadius = ScreenMultiple * Primitive.ObjectWorldPositionAndRadius.w / 
                                    max(1.0, dot(TreePos - ResolvedView.WorldCameraOrigin, ResolvedView.ViewForward.xyz));
        const float ScreenArea = PI * ScreenRadius * ScreenRadius * View.ViewSizeAndInvSize.z * View.ViewSizeAndInvSize.w;
        LodInterp = saturate((ScreenArea - SpeedTreeLODInfo.x) / SpeedTreeLODInfo.z);
    }
#endif
    TreePos *= 0.001; // The only other use of the tree position is as an offset into trig functions, but big numbers don't play nice there

    // SpeedTrees should only be uniformly scaled, but if necessary, it takes a few more instructions
    float TreeScale = length(mul(float3(0,0,1), LocalToWorld));
                    //float3(length((float3)LocalToWorld[0]),
                    //        length((float3)LocalToWorld[1]),
                    //        length((float3)LocalToWorld[2]));


    // @todo There is probably a more optimal way to get the rotated (but not translated or scaled) vertex position needed for correct wind
    float3 OriginalPosition = LocalPosition;
    OriginalPosition = mul(OriginalPosition, LocalToWorld) / TreeScale;

    float3 FinalPosition = OriginalPosition;
    
    if (GeometryType == SPEEDTREE_GEOMETRY_TYPE_BILLBOARD)
    {
        if (BillboardThreshold < 1.0)
        {
            // billboard meshes can have triangles drop out if they aren't facing the camera
            // this rotates the view direction around so we ignore the local Z component
            float3 LocalView2D = normalize(float3(ResolvedView.ViewForward.xy, 0));
            float3 LocalNormal2D = normalize(float3(Parameters.TangentToWorld[2].xy, 0));
            if (dot(LocalView2D, LocalNormal2D) > (-1.0 + BillboardThreshold * 0.25))
            {
                FinalPosition = float3(0,0,0);
            }
        }
    }
    else
    {
        // rotated normal needed in a few places
        float3 Normal = Parameters.TangentToWorld[2];

        // branches and fronds
        if (GeometryType == SPEEDTREE_GEOMETRY_TYPE_BRANCH || GeometryType == SPEEDTREE_GEOMETRY_TYPE_FROND) 
        {
            // smooth LOD
            #if !USE_INSTANCING
                if (LODType == SPEEDTREE_LOD_TYPE_SMOOTH) 
                {
                    float3 LODPos = float3(Parameters.TexCoords[3].x, Parameters.TexCoords[3].y, Parameters.TexCoords[4].x);
                    LODPos = mul(LODPos, LocalToWorld) / TreeScale;
                    FinalPosition = lerp(LODPos, FinalPosition, LodInterp);
                }
            #endif

            // frond wind, if needed
            if (GeometryType == SPEEDTREE_GEOMETRY_TYPE_FROND && WindType == SPEEDTREE_WIND_TYPE_PALM)
            {
                float2 TexCoords = Parameters.TexCoords[0];
                float4 WindExtra = float4(Parameters.TexCoords[5].x, Parameters.TexCoords[5].y, Parameters.TexCoords[6].x, 0.0);
                FinalPosition = RippleFrond(STData, FinalPosition, Normal, TexCoords.x, TexCoords.y, WindExtra.x, WindExtra.y, WindExtra.z);
            }
        }

        // leaves and facing leaves
        if (GeometryType == SPEEDTREE_GEOMETRY_TYPE_FACINGLEAF || 
                (GeometryType == SPEEDTREE_GEOMETRY_TYPE_LEAF && 
                (LODType == SPEEDTREE_LOD_TYPE_SMOOTH || (WindType > SPEEDTREE_WIND_TYPE_FASTEST && WindType != SPEEDTREE_WIND_TYPE_PALM))))
        {
            // remove anchor pos from vertex position
            float3 Anchor = float3(Parameters.TexCoords[4].y, Parameters.TexCoords[5].x, Parameters.TexCoords[5].y);
            Anchor = (mul(Anchor, LocalToWorld)) / TreeScale;
            FinalPosition -= Anchor;

            // smooth LOD
            #if !USE_INSTANCING
                if (LODType == SPEEDTREE_LOD_TYPE_SMOOTH) 
                {
                    if (GeometryType == SPEEDTREE_GEOMETRY_TYPE_LEAF)
                    {
                        float3 LODPos = float3(Parameters.TexCoords[3].x, Parameters.TexCoords[3].y, Parameters.TexCoords[4].x);
                        LODPos = mul(LODPos, LocalToWorld) / TreeScale - Anchor;
                        FinalPosition = lerp(LODPos, FinalPosition, LodInterp);
                    }
                    else
                    {
                        float LODScalar = Parameters.TexCoords[3].x;
                        FinalPosition *= lerp(LODScalar, 1.0, LodInterp);
                    }
                }
            #endif

            // face camera-facing leaves to the camera, if needed
            if (GeometryType == SPEEDTREE_GEOMETRY_TYPE_FACINGLEAF) 
            {
                // have to rotate the view into local space
                FinalPosition = FinalPosition.x * ResolvedView.ViewRight + 
                                FinalPosition.y * ResolvedView.ViewUp + 
                                FinalPosition.z * ResolvedView.ViewForward;
            }

            // leaf wind
            if (WindType > SPEEDTREE_WIND_TYPE_FASTEST && WindType != SPEEDTREE_WIND_TYPE_PALM) 
            {
                float4 WindExtra = float4(Parameters.TexCoords[6].x, Parameters.TexCoords[6].y, Parameters.TexCoords[7].x, Parameters.TexCoords[7].y);
                float LeafWindTrigOffset = Anchor.x + Anchor.y;
                FinalPosition = LeafWind(STData, WindExtra.w > 0.0, FinalPosition, Normal, WindExtra.x, float3(0,0,0), WindExtra.y, WindExtra.z, LeafWindTrigOffset, WindType);
            }
                
            // move leaf back to anchor
            FinalPosition += Anchor;
        }

        if (WindType > SPEEDTREE_WIND_TYPE_FAST)
        {
            // branch wind (applies to all geometry)
            float2 VertBranchWind = Parameters.TexCoords[2];
            FinalPosition = BranchWind(STData, FinalPosition, TreePos, float4(VertBranchWind, 0, 0), WindType);
        }    
    }

    // global wind can apply to the whole tree, even billboards
    if (WindType != SPEEDTREE_WIND_TYPE_NONE)
    {
        FinalPosition = GlobalWind(STData, FinalPosition, TreePos, true);
    }

    // convert into a world space offset
    return (FinalPosition - OriginalPosition) * TreeScale;
}

/** Vertex offset for SpeedTree wind and LOD */
float3 GetSpeedTreeVertexOffset(FMaterialVertexParameters Parameters, int GeometryType, int WindType, int LODType, float BillboardThreshold, bool bUsePreviousFrame) 
{
#if VF_SUPPORTS_SPEEDTREE_WIND
    if (bUsePreviousFrame)
    {
        return GetSpeedTreeVertexOffsetInner(Parameters, GeometryType, WindType, LODType, BillboardThreshold, GetPreviousSpeedTreeData());
    }
    return GetSpeedTreeVertexOffsetInner(Parameters, GeometryType, WindType, LODType, BillboardThreshold, GetCurrentSpeedTreeData());
#else
    return 0;
#endif
}

#endif

MaterialFloat2 GetLightmapUVs(FMaterialPixelParameters Parameters)
{
#if LIGHTMAP_UV_ACCESS
    return Parameters.LightmapUVs;
#else
    return MaterialFloat2(0,0);
#endif
}

#if USES_EYE_ADAPTATION
#include "/Engine/Private/EyeAdaptationCommon.ush"
#endif

#if POST_PROCESS_MATERIAL
// only Postprocess material bind PostprocessInput0, PostprocessInput0Size, PostprocessInput0MinMax ...
#include "/Engine/Private/PostProcessCommon.ush"            // PostprocessInput0
#endif

#if NEEDS_SCENE_TEXTURES
#include "/Engine/Private/DeferredShadingCommon.ush"        // GetGBufferData()

float4 GetPostProcessInputSize(uint Index)
{
#if POST_PROCESS_MATERIAL
         if (Index == 0)    return PostprocessInput0Size;
    else if (Index == 1)    return PostprocessInput1Size;
    else if (Index == 2)    return PostprocessInput2Size;
    else if (Index == 3)    return PostprocessInput3Size;
    else if (Index == 4)    return PostprocessInput4Size;
    else if (Index == 5)    return PostprocessInput5Size;
    else if (Index == 6)    return PostprocessInput6Size;
#endif
    return 1.0f;
}

float4 GetPostProcessInputMinMax(uint Index)
{
#if POST_PROCESS_MATERIAL
         if (Index == 0)    return PostprocessInput0MinMax;
    else if (Index == 1)    return PostprocessInput1MinMax;
    else if (Index == 2)    return PostprocessInput2MinMax;
    else if (Index == 3)    return PostprocessInput3MinMax;
    else if (Index == 4)    return PostprocessInput4MinMax;
    else if (Index == 5)    return PostprocessInput5MinMax;
    else if (Index == 6)    return PostprocessInput6MinMax;
#endif
    return 1.0f;
}

MaterialFloat4 MobileSceneTextureLookup(inout FMaterialPixelParameters Parameters, int SceneTextureId, float2 UV)
{
#if (FEATURE_LEVEL <= FEATURE_LEVEL_ES3_1)
    
    // For fetching SceneDepth and CustomDepth after tonemapper we need to switch OpenGL coordinates
    // SceneColor will be transformed to OpenGL coordinates during tonemapping
    #define NEEDTOSWITCHVERTICLEAXIS (COMPILER_GLSL_ES2 || COMPILER_GLSL_ES3_1) && (POST_PROCESS_MATERIAL && !POST_PROCESS_MATERIAL_BEFORE_TONEMAP)
    
    //PPI_SceneDepth
    if (SceneTextureId == 1)
    {
        #if NEEDTOSWITCHVERTICLEAXIS
        UV.y = 1.0 - UV.y; 
        #endif
        
        MaterialFloat Depth = ConvertFromDeviceZ(Texture2DSample(SceneDepthTexture, SceneDepthTextureSampler, UV).r);
        return MaterialFloat4(Depth.rrr, 0.f);
    }
    //PPI_CustomDepth
    else if (SceneTextureId == 13)
    {
        #if NEEDTOSWITCHVERTICLEAXIS
        UV.y = 1.0 - UV.y; 
        #endif

        MaterialFloat Depth = ConvertFromDeviceZ(Texture2DSample(CustomDepthTexture, CustomDepthTextureSampler, UV).r);
        return MaterialFloat4(Depth.rrr, 0.f);
    }
    // PPI_PostprocessInput
    else if (SceneTextureId == 14)
    {
#if POST_PROCESS_MATERIAL    
        MaterialFloat4 Input0 = Texture2DSample(PostprocessInput0, PostprocessInput0Sampler, UV);
        #if POST_PROCESS_MATERIAL_BEFORE_TONEMAP
        Input0 = Decode32BPPHDR(Input0);
        #endif
        // We need to preserve original SceneColor Alpha as it's used by tonemaper on mobile
        Parameters.BackupSceneColorAlpha = Input0.a;
        return Input0;
#endif// POST_PROCESS_MATERIAL    
    }
    // PPI_CustomStencil
    else if (SceneTextureId == 24)
    {
        #if NEEDTOSWITCHVERTICLEAXIS
        UV.y = 1.0 - UV.y; 
        #endif

        MaterialFloat Stencil = Texture2DSample(MobileCustomStencilTexture, MobileCustomStencilTextureSampler, UV).r*255.0;
        Stencil = floor(Stencil + 0.5);
        return MaterialFloat4(Stencil.rrr, 0.f);
    }
#endif// FEATURE_LEVEL

    return MaterialFloat4(0.0f, 0.0f, 0.0f, 0.0f);
}

/** Applies an offset to the scene texture lookup and decodes the HDR linear space color. */
float4 SceneTextureLookup(float2 UV, int SceneTextureIndex, bool bFiltered)
{
#if SCENE_TEXTURES_DISABLED
    return float4(0.0f, 0.0f, 0.0f, 0.0f);
#endif

    FScreenSpaceData ScreenSpaceData = GetScreenSpaceData(UV, false);
    switch(SceneTextureIndex)
    {
        // order needs to match to ESceneTextureId

        // PPI_SceneColor
        case 0: return float4(CalcSceneColor(UV), 0);
        // PPI_SceneDepth
        case 1: return ScreenSpaceData.GBuffer.Depth;
        // PPI_DiffuseColor
        case 2: return float4(ScreenSpaceData.GBuffer.DiffuseColor, 0);
        // PPI_SpecularColor
        case 3: return float4(ScreenSpaceData.GBuffer.SpecularColor, 0);
        // PPI_SubsurfaceColor
        case 4: return IsSubsurfaceModel(ScreenSpaceData.GBuffer.ShadingModelID) ? float4( ExtractSubsurfaceColor(ScreenSpaceData.GBuffer), ScreenSpaceData.GBuffer.CustomData.a ) : ScreenSpaceData.GBuffer.CustomData;
        // PPI_BaseColor
        case 5: return float4(ScreenSpaceData.GBuffer.BaseColor, 0);
        // PPI_Specular
        case 6: return ScreenSpaceData.GBuffer.Specular;
        // PPI_Metallic
        case 7: return ScreenSpaceData.GBuffer.Metallic;
        // PPI_WorldNormal
        case 8: return float4(ScreenSpaceData.GBuffer.WorldNormal, 0);
        // PPI_SeparateTranslucency
        case 9: return float4(1, 1, 1, 1);    // todo
        // PPI_Opacity
        case 10: return ScreenSpaceData.GBuffer.CustomData.a;
        // PPI_Roughness
        case 11: return ScreenSpaceData.GBuffer.Roughness;
        // PPI_MaterialAO
        case 12: return ScreenSpaceData.GBuffer.GBufferAO;
        // PPI_CustomDepth
        case 13: return ScreenSpaceData.GBuffer.CustomDepth;
#if POST_PROCESS_MATERIAL
        // PPI_PostprocessInput0
        case 14: return Texture2DSample(PostprocessInput0, bFiltered ? BilinearTextureSampler0 : PostprocessInput0Sampler, UV);
        // PPI_PostprocessInput1
        case 15: return Texture2DSample(PostprocessInput1, bFiltered ? BilinearTextureSampler0 : PostprocessInput1Sampler, UV);
        // PPI_PostprocessInput2
        case 16: return Texture2DSample(PostprocessInput2, bFiltered ? BilinearTextureSampler0 : PostprocessInput2Sampler, UV);
        // PPI_PostprocessInput3
        case 17: return Texture2DSample(PostprocessInput3, bFiltered ? BilinearTextureSampler0 : PostprocessInput3Sampler, UV);
        // PPI_PostprocessInput4
        case 18: return Texture2DSample(PostprocessInput4, bFiltered ? BilinearTextureSampler0 : PostprocessInput4Sampler, UV);
        // PPI_PostprocessInput5
        case 19: return Texture2DSample(PostprocessInput5, bFiltered ? BilinearTextureSampler0 : PostprocessInput5Sampler, UV);
        // PPI_PostprocessInput6
        case 20: return Texture2DSample(PostprocessInput6, bFiltered ? BilinearTextureSampler0 : PostprocessInput6Sampler, UV);
#endif // __POST_PROCESS_COMMON__
        // PPI_DecalMask
        case 21: return 0;  // material compiler will return an error
        // PPI_ShadingModel
        case 22: return float4(GetShadingModelColor(ScreenSpaceData.GBuffer.ShadingModelID), 1);
        // PPI_AmbientOcclusion
        case 23: return ScreenSpaceData.AmbientOcclusion;
        // PPI_CustomStencil
        case 24: return ScreenSpaceData.GBuffer.CustomStencil;
        // PPI_StoredBaseColor
        case 25: return float4(ScreenSpaceData.GBuffer.StoredBaseColor, 0);
        // PPI_StoredSpecular
        case 26: return float4(ScreenSpaceData.GBuffer.StoredSpecular.rrr, 0);
        default:
            return float4(0, 0, 0, 0);
    }
}
#endif // NEEDS_SCENE_TEXTURES

// Uniform material expressions.


// can return in tangent space or world space (use MATERIAL_TANGENTSPACENORMAL)
half3 GetMaterialNormalRaw(FPixelMaterialInputs PixelMaterialInputs)
{
    return PixelMaterialInputs.Normal;
}

half3 GetMaterialNormal(FMaterialPixelParameters Parameters, FPixelMaterialInputs PixelMaterialInputs)
{
    half3 RetNormal;

    RetNormal = GetMaterialNormalRaw(PixelMaterialInputs);
        
    #if (USE_EDITOR_SHADERS && !(ES2_PROFILE || ES3_1_PROFILE || ESDEFERRED_PROFILE)) || MOBILE_EMULATION
    {
        // this feature is only needed for development/editor - we can compile it out for a shipping build (see r.CompileShadersForDevelopment cvar help)
        half3 OverrideNormal = View.NormalOverrideParameter.xyz;

        #if !MATERIAL_TANGENTSPACENORMAL
            OverrideNormal = Parameters.TangentToWorld[2] * (1 - View.NormalOverrideParameter.w);
        #endif

        RetNormal = RetNormal * View.NormalOverrideParameter.w + OverrideNormal;
    }
    #endif

    return RetNormal;
}

half3 GetMaterialEmissiveRaw(FPixelMaterialInputs PixelMaterialInputs)
{
    return PixelMaterialInputs.EmissiveColor;
}

half3 GetMaterialEmissive(FPixelMaterialInputs PixelMaterialInputs)
{
    half3 EmissiveColor = GetMaterialEmissiveRaw(PixelMaterialInputs);
#if !MATERIAL_ALLOW_NEGATIVE_EMISSIVECOLOR
    EmissiveColor = max(EmissiveColor, 0.0f);
#endif
    return EmissiveColor;
}

half3 GetMaterialEmissiveForCS(FMaterialPixelParameters Parameters)
{
return 0;
}

half3 GetMaterialBaseColorRaw(FPixelMaterialInputs PixelMaterialInputs)
{
    return PixelMaterialInputs.BaseColor;
}

half3 GetMaterialBaseColor(FPixelMaterialInputs PixelMaterialInputs)
{
    return saturate(GetMaterialBaseColorRaw(PixelMaterialInputs));
}

half GetMaterialMetallicRaw(FPixelMaterialInputs PixelMaterialInputs)
{
    return PixelMaterialInputs.Metallic;
}

half GetMaterialMetallic(FPixelMaterialInputs PixelMaterialInputs)
{
    return saturate(GetMaterialMetallicRaw(PixelMaterialInputs));
}

half GetMaterialSpecularRaw(FPixelMaterialInputs PixelMaterialInputs)
{
    return PixelMaterialInputs.Specular;
}

half GetMaterialSpecular(FPixelMaterialInputs PixelMaterialInputs)
{
    return saturate(GetMaterialSpecularRaw(PixelMaterialInputs));
}

half GetMaterialRoughnessRaw(FPixelMaterialInputs PixelMaterialInputs)
{
    return PixelMaterialInputs.Roughness;
}

half GetMaterialRoughness(FPixelMaterialInputs PixelMaterialInputs)
{
#if MATERIAL_FULLY_ROUGH
    return 1;
#endif
#if (ES2_PROFILE || ES3_1_PROFILE)
    // The smallest normalized value that can be represented in IEEE 754 (FP16) is 2^-14 = 6.1e-5.
    // The code will make the following computation involving roughness: 1.0 / Roughness^4.
    // Therefore to prevent division by zero on devices that do not support denormals, Roughness^4
    // must be >= 6.1e-5. We will clamp to 0.09 because 0.09^4 = 6.5e-5.
    //
    // Note that we also clamp to 1.0 to match the deferred renderer on PC where the roughness is 
    // stored in an 8-bit value and thus automatically clamped at 1.0.

    half Roughness = GetMaterialRoughnessRaw(PixelMaterialInputs);

    #if MOBILE_EMULATION
    {
        // this is only needed for mobile preview on PC
        Roughness = Roughness * View.RoughnessOverrideParameter.y + View.RoughnessOverrideParameter.x;
    }
    #endif

    // Increase value from 0.09 to 0.12 to fix missing specular lobe problem on device
    return clamp( Roughness, 0.12, 1.0 );
#else
    half Roughness = saturate(GetMaterialRoughnessRaw(PixelMaterialInputs));
    
    #if (USE_EDITOR_SHADERS && !ESDEFERRED_PROFILE)
    {
        // this feature is only needed for development/editor - we can compile it out for a shipping build (see r.CompileShadersForDevelopment cvar help)
        Roughness = Roughness * View.RoughnessOverrideParameter.y + View.RoughnessOverrideParameter.x;
    }
    #endif
    
    return Roughness;
#endif
}

half GetMaterialTranslucencyDirectionalLightingIntensity()
{
return 1.00000;
}

half GetMaterialTranslucentShadowDensityScale()
{
return 0.50000;
}

half GetMaterialTranslucentSelfShadowDensityScale()
{
return 2.00000;
}

half GetMaterialTranslucentSelfShadowSecondDensityScale()
{
return 10.00000;
}

half GetMaterialTranslucentSelfShadowSecondOpacity()
{
return 0.00000;
}

half GetMaterialTranslucentBackscatteringExponent()
{
return 30.00000;
}

half3 GetMaterialTranslucentMultipleScatteringExtinction()
{
return MaterialFloat3(1.00000, 0.83300, 0.58800);
}

// This is the clip value constant that is defined in the material (range 0..1)
// Use GetMaterialMask() to get the Material Mask combined with this.
half GetMaterialOpacityMaskClipValue()
{
return 0.33330;
}

// Should only be used by GetMaterialOpacity(), returns the unmodified value generated from the shader expressions of the opacity input.
// To compute the opacity depending on the material blending GetMaterialOpacity() should be called instead.
half GetMaterialOpacityRaw(FPixelMaterialInputs PixelMaterialInputs)
{
    return PixelMaterialInputs.Opacity;
}

#if MATERIALBLENDING_MASKED || (DECAL_BLEND_MODE == DECALBLENDMODEID_VOLUMETRIC)
// Returns the material mask value generated from the material expressions.
// Use GetMaterialMask() to get the value altered depending on the material blend mode.
half GetMaterialMaskInputRaw(FPixelMaterialInputs PixelMaterialInputs)
{
    return PixelMaterialInputs.OpacityMask;
}

// Returns the material mask value generated from the material expressions minus the used defined
// MaskClip value constant. If this value is <=0 the pixel should be killed.
half GetMaterialMask(FPixelMaterialInputs PixelMaterialInputs)
{
    return GetMaterialMaskInputRaw(PixelMaterialInputs) - GetMaterialOpacityMaskClipValue();
}
#endif

// Returns the material opacity depending on the material blend mode.
half GetMaterialOpacity(FPixelMaterialInputs PixelMaterialInputs)
{
    // Clamp to valid range to prevent negative colors from lerping
    return saturate(GetMaterialOpacityRaw(PixelMaterialInputs));
}

#if TRANSLUCENT_SHADOW_WITH_MASKED_OPACITY
half GetMaterialMaskedOpacity(FPixelMaterialInputs PixelMaterialInputs)
{
    return GetMaterialOpacity(PixelMaterialInputs) - GetMaterialOpacityMaskClipValue();
}
#endif

float3 GetMaterialWorldPositionOffset(FMaterialVertexParameters Parameters)
{
    #if USE_INSTANCING
        // skip if this instance is hidden
        if (Parameters.PerInstanceParams.z < 1.f)
        {
            return float3(0,0,0);
        }
    #endif
    return MaterialFloat3(0.00000000,0.00000000,0.00000000);;
}

float3 GetMaterialPreviousWorldPositionOffset(FMaterialVertexParameters Parameters)
{
    #if USE_INSTANCING
        // skip if this instance is hidden
        if (Parameters.PerInstanceParams.z < 1.f)
        {
            return float3(0,0,0);
        }
    #endif
    return MaterialFloat3(0.00000000,0.00000000,0.00000000);;
}

half3 GetMaterialWorldDisplacement(FMaterialTessellationParameters Parameters)
{
    return MaterialFloat3(0.00000000,0.00000000,0.00000000);;
}

half GetMaterialMaxDisplacement()
{
return 0.00000;
}

half GetMaterialTessellationMultiplier(FMaterialTessellationParameters Parameters)
{
    return 1.00000000;;
}

// .rgb:SubsurfaceColor, .a:SSProfileId in 0..1 range
half4 GetMaterialSubsurfaceDataRaw(FPixelMaterialInputs PixelMaterialInputs)
{
    return PixelMaterialInputs.Subsurface;
}

half4 GetMaterialSubsurfaceData(FPixelMaterialInputs PixelMaterialInputs)
{
    half4 OutSubsurface = GetMaterialSubsurfaceDataRaw(PixelMaterialInputs);
    OutSubsurface.rgb = saturate(OutSubsurface.rgb);
    return OutSubsurface;
}

half GetMaterialCustomData0(FMaterialPixelParameters Parameters)
{
    return 1.00000000;;
}

half GetMaterialCustomData1(FMaterialPixelParameters Parameters)
{
    return 0.10000000;;
}

half GetMaterialAmbientOcclusionRaw(FPixelMaterialInputs PixelMaterialInputs)
{
    return PixelMaterialInputs.AmbientOcclusion;
}

half GetMaterialAmbientOcclusion(FPixelMaterialInputs PixelMaterialInputs)
{
    return saturate(GetMaterialAmbientOcclusionRaw(PixelMaterialInputs));
}

half2 GetMaterialRefraction(FPixelMaterialInputs PixelMaterialInputs)
{
    return PixelMaterialInputs.Refraction;
}

#if NUM_TEX_COORD_INTERPOLATORS
void GetMaterialCustomizedUVs(FMaterialVertexParameters Parameters, inout float2 OutTexCoords[NUM_TEX_COORD_INTERPOLATORS])
{
    OutTexCoords[0] = Parameters.TexCoords[0].xy;

}

void GetCustomInterpolators(FMaterialVertexParameters Parameters, inout float2 OutTexCoords[NUM_TEX_COORD_INTERPOLATORS])
{

}
#endif

float GetMaterialPixelDepthOffset(FPixelMaterialInputs PixelMaterialInputs)
{
    return PixelMaterialInputs.PixelDepthOffset;
}

#if DECAL_PRIMITIVE

float3 TransformTangentNormalToWorld(in FMaterialPixelParameters Parameters, float3 TangentNormal)
{
    // To transform the normals use tranpose(Inverse(DecalToWorld)) = transpose(WorldToDecal)
    // But we want to only rotate the normals (we don't want to non-uniformaly scale them).
    // We assume the matrix is only a scale and rotation, and we remove non-uniform scale:
    float3 lengthSqr = { length2(DecalToWorld._m00_m01_m02),
                            length2(DecalToWorld._m10_m11_m12),
                            length2(DecalToWorld._m20_m21_m22) };

    float3 scale = rsqrt(lengthSqr);
                
    // Pre-multiply by the inverse of the non-uniform scale in DecalToWorld
    float4 ScaledNormal = float4(-TangentNormal.z * scale.x, TangentNormal.y * scale.y, TangentNormal.x * scale.z, 0.f);

    // Compute the normal 
    return normalize(mul(ScaledNormal, DecalToWorld).xyz);
}

#else //DECAL_PRIMITIVE

float3 TransformTangentNormalToWorld(in FMaterialPixelParameters Parameters, float3 TangentNormal)
{
    return normalize(float3(TransformTangentVectorToWorld(Parameters.TangentToWorld, TangentNormal)));
}

#endif //DECAL_PRIMITIVE

void CalcPixelMaterialInputs(in out FMaterialPixelParameters Parameters, in out FPixelMaterialInputs PixelMaterialInputs)
{
    // Initial calculations (required for Normal)
    MaterialFloat3 Local0 = lerp(MaterialFloat3(0.00000000,0.00000000,1.00000000),MaterialFloat3(1.00000000,1.00000000,1.00000000),MaterialFloat(Material.ScalarExpressions[0].x));
    MaterialFloat3 Local1 = (GetWorldPosition(Parameters) / Material.ScalarExpressions[0].z);
    MaterialFloat4 Local2 = UnpackNormalMap(Texture2DSample(Material.Texture2D_0,Material.Texture2D_0Sampler,Local1.rb));
    MaterialFloat3 Local3 = mul(MaterialFloat3(0.00000000,0.00000000,1.00000000), (MaterialFloat3x3)(Parameters.TangentToWorld));
    MaterialFloat Local4 = (Local3.g * 0.50000000);
    MaterialFloat Local5 = (Local4 + 0.50000000);
    MaterialFloat2 Local6 = lerp(MaterialFloat2(1.00000000,1.00000000),MaterialFloat2(1.00000000,-1.00000000),MaterialFloat(Local5));
    MaterialFloat2 Local7 = (Local2.rgb.rg * Local6);
    MaterialFloat4 Local8 = UnpackNormalMap(Texture2DSample(Material.Texture2D_0,Material.Texture2D_0Sampler,Local1.rb));
    MaterialFloat4 Local9 = UnpackNormalMap(Texture2DSample(Material.Texture2D_0,Material.Texture2D_0Sampler,Local1.gb));
    MaterialFloat4 Local10 = UnpackNormalMap(Texture2DSample(Material.Texture2D_0,Material.Texture2D_0Sampler,Local1.gb));
    MaterialFloat Local11 = (Local3.r * 0.50000000);
    MaterialFloat Local12 = (Local11 + 0.50000000);
    MaterialFloat2 Local13 = lerp(MaterialFloat2(1.00000000,1.00000000),MaterialFloat2(-1.00000000,1.00000000),MaterialFloat(Local12));
    MaterialFloat2 Local14 = (MaterialFloat2(Local9.g,Local10.r) * Local13);
    MaterialFloat4 Local15 = UnpackNormalMap(Texture2DSample(Material.Texture2D_0,Material.Texture2D_0Sampler,Local1.gb));
    MaterialFloat Local16 = abs(Local3.r);
    MaterialFloat Local17 = lerp((0.00000000 - 4.00000000),(4.00000000 + 1.00000000),Local16);
    MaterialFloat Local18 = min(max(Local17,0.00000000),1.00000000);
    MaterialFloat3 Local19 = lerp(MaterialFloat3(Local7,Local8.b),MaterialFloat3(Local14,Local15.b),MaterialFloat(Local18));
    MaterialFloat4 Local20 = UnpackNormalMap(Texture2DSample(Material.Texture2D_0,Material.Texture2D_0Sampler,Local1.rg));
    MaterialFloat Local21 = abs(Local3.b);
    MaterialFloat Local22 = lerp((0.00000000 - 4.00000000),(4.00000000 + 1.00000000),Local21);
    MaterialFloat Local23 = (Local22 + -2.00000000);
    MaterialFloat Local24 = min(max(Local23,0.00000000),1.00000000);
    MaterialFloat3 Local25 = lerp(Local19,Local20.rgb,MaterialFloat(Local24));
    MaterialFloat3 Local26 = (Local0 * Local25.rgb);
    MaterialFloat3 Local27 = lerp(MaterialFloat3(0.00000000,0.00000000,1.00000000),MaterialFloat3(1.00000000,1.00000000,1.00000000),MaterialFloat(Material.ScalarExpressions[0].w));
    MaterialFloat3 Local28 = (GetWorldPosition(Parameters) / Material.ScalarExpressions[1].y);
    MaterialFloat4 Local29 = UnpackNormalMap(Texture2DSample(Material.Texture2D_0,Material.Texture2D_0Sampler,Local28.rb));
    MaterialFloat3 Local30 = mul(MaterialFloat3(0.00000000,0.00000000,1.00000000), (MaterialFloat3x3)(Parameters.TangentToWorld));
    MaterialFloat Local31 = (Local30.g * 0.50000000);
    MaterialFloat Local32 = (Local31 + 0.50000000);
    MaterialFloat2 Local33 = lerp(MaterialFloat2(1.00000000,1.00000000),MaterialFloat2(1.00000000,-1.00000000),MaterialFloat(Local32));
    MaterialFloat2 Local34 = (Local29.rgb.rg * Local33);
    MaterialFloat4 Local35 = UnpackNormalMap(Texture2DSample(Material.Texture2D_0,Material.Texture2D_0Sampler,Local28.rb));
    MaterialFloat4 Local36 = UnpackNormalMap(Texture2DSample(Material.Texture2D_0,Material.Texture2D_0Sampler,Local28.gb));
    MaterialFloat4 Local37 = UnpackNormalMap(Texture2DSample(Material.Texture2D_0,Material.Texture2D_0Sampler,Local28.gb));
    MaterialFloat Local38 = (Local30.r * 0.50000000);
    MaterialFloat Local39 = (Local38 + 0.50000000);
    MaterialFloat2 Local40 = lerp(MaterialFloat2(1.00000000,1.00000000),MaterialFloat2(-1.00000000,1.00000000),MaterialFloat(Local39));
    MaterialFloat2 Local41 = (MaterialFloat2(Local36.g,Local37.r) * Local40);
    MaterialFloat4 Local42 = UnpackNormalMap(Texture2DSample(Material.Texture2D_0,Material.Texture2D_0Sampler,Local28.gb));
    MaterialFloat Local43 = abs(Local30.r);
    MaterialFloat Local44 = lerp((0.00000000 - 4.00000000),(4.00000000 + 1.00000000),Local43);
    MaterialFloat Local45 = min(max(Local44,0.00000000),1.00000000);
    MaterialFloat3 Local46 = lerp(MaterialFloat3(Local34,Local35.b),MaterialFloat3(Local41,Local42.b),MaterialFloat(Local45));
    MaterialFloat4 Local47 = UnpackNormalMap(Texture2DSample(Material.Texture2D_0,Material.Texture2D_0Sampler,Local28.rg));
    MaterialFloat Local48 = abs(Local30.b);
    MaterialFloat Local49 = lerp((0.00000000 - 4.00000000),(4.00000000 + 1.00000000),Local48);
    MaterialFloat Local50 = (Local49 + -2.00000000);
    MaterialFloat Local51 = min(max(Local50,0.00000000),1.00000000);
    MaterialFloat3 Local52 = lerp(Local46,Local47.rgb,MaterialFloat(Local51));
    MaterialFloat3 Local53 = (Local27 * Local52.rgb);
    MaterialFloat3 Local54 = (Local53 * MaterialFloat3(1.00000000,1.00000000,0.00000000));
    MaterialFloat3 Local55 = (Local26 + Local54);
    MaterialFloat Local56 = dot(Local55, Local55);
    MaterialFloat Local57 = sqrt(Local56);
    MaterialFloat3 Local58 = (Local55 / Local57);
    MaterialFloat3 Local59 = ResolvedView.WorldCameraOrigin;
    MaterialFloat3 Local60 = (GetWorldPosition(Parameters) - Local59);
    MaterialFloat Local61 = dot(Local60, Local60);
    MaterialFloat Local62 = sqrt(Local61);
    MaterialFloat Local63 = (Local62 / Material.ScalarExpressions[1].z);
    MaterialFloat Local64 = min(max(Local63,0.00000000),1.00000000);
    MaterialFloat3 Local65 = lerp(Local58,Local53,MaterialFloat(Local64));
    MaterialFloat3 Local66 = lerp(MaterialFloat3(0.00000000,0.00000000,1.00000000),MaterialFloat3(1.00000000,1.00000000,1.00000000),MaterialFloat(Material.ScalarExpressions[1].w));
    MaterialFloat Local67 = dot(Parameters.TexCoords[0].xy, MaterialFloat2(-0.00000000,1.00000000));
    MaterialFloat Local68 = dot(Parameters.TexCoords[0].xy, MaterialFloat2(1.00000000,0.00000000));
    MaterialFloat2 Local69 = (1.00000000 * MaterialFloat2(Local68,Local67));
    MaterialFloat2 Local70 = (Local69 + MaterialFloat2(0.00000000,0.00000000));
    MaterialFloat2 Local71 = (Local70 / Material.VectorExpressions[1].rg);
    MaterialFloat2 Local72 = (Local71 * Material.ScalarExpressions[2].y);
    MaterialFloat4 Local73 = UnpackNormalMap(Texture2DSample(Material.Texture2D_1,Material.Texture2D_1Sampler,Local72));
    MaterialFloat3 Local74 = (Local66 * Local73.rgb);
    MaterialFloat3 Local75 = lerp(MaterialFloat3(0.00000000,0.00000000,1.00000000),MaterialFloat3(1.00000000,1.00000000,1.00000000),MaterialFloat(Material.ScalarExpressions[2].z));
    MaterialFloat Local76 = dot(Parameters.TexCoords[0].xy, MaterialFloat2(-0.00000000,1.00000000));
    MaterialFloat Local77 = dot(Parameters.TexCoords[0].xy, MaterialFloat2(1.00000000,0.00000000));
    MaterialFloat2 Local78 = (1.00000000 * MaterialFloat2(Local77,Local76));
    MaterialFloat2 Local79 = (Local78 + MaterialFloat2(0.00000000,0.00000000));
    MaterialFloat2 Local80 = (Local79 / Material.VectorExpressions[2].rg);
    MaterialFloat2 Local81 = (Local80 * Material.ScalarExpressions[2].y);
    MaterialFloat4 Local82 = UnpackNormalMap(Texture2DSample(Material.Texture2D_1,Material.Texture2D_1Sampler,Local81));
    MaterialFloat3 Local83 = (Local75 * Local82.rgb);
    MaterialFloat3 Local84 = (Local83 * MaterialFloat3(1.00000000,1.00000000,0.00000000));
    MaterialFloat3 Local85 = (Local74 + Local84);
    MaterialFloat Local86 = dot(Local85, Local85);
    MaterialFloat Local87 = sqrt(Local86);
    MaterialFloat3 Local88 = (Local85 / Local87);
    MaterialFloat3 Local89 = ResolvedView.WorldCameraOrigin;
    MaterialFloat3 Local90 = (GetWorldPosition(Parameters) - Local89);
    MaterialFloat Local91 = dot(Local90, Local90);
    MaterialFloat Local92 = sqrt(Local91);
    MaterialFloat Local93 = (Local92 / Material.ScalarExpressions[1].z);
    MaterialFloat Local94 = min(max(Local93,0.00000000),1.00000000);
    MaterialFloat3 Local95 = lerp(Local88,Local83,MaterialFloat(Local94));
    MaterialFloat Local96 = lerp(Material.ScalarExpressions[3].y,Material.ScalarExpressions[3].x,(0.00000000 + (1.00000000 * 0.00000000)));
    MaterialFloat Local97 = (GetWorldPosition(Parameters).r + GetWorldPosition(Parameters).g);
    MaterialFloat2 Local98 = (MaterialFloat2(Local97,GetWorldPosition(Parameters).b) / Material.VectorExpressions[6].rg);
    MaterialFloat4 Local99 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_2,Material.Texture2D_2Sampler,Local98));
    MaterialFloat Local100 = (Local99.r * Material.ScalarExpressions[4].y);
    MaterialFloat3 Local101 = (GetWorldPosition(Parameters) / Material.ScalarExpressions[0].z);
    MaterialFloat4 Local102 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local101.rb));
    MaterialFloat4 Local103 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local101.rb));
    MaterialFloat4 Local104 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local101.gb));
    MaterialFloat4 Local105 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local101.gb));
    MaterialFloat3 Local106 = mul(MaterialFloat3(0.00000000,0.00000000,1.00000000), (MaterialFloat3x3)(Parameters.TangentToWorld));
    MaterialFloat Local107 = abs(Local106.r);
    MaterialFloat Local108 = lerp((0.00000000 - 4.00000000),(4.00000000 + 1.00000000),Local107);
    MaterialFloat Local109 = min(max(Local108,0.00000000),1.00000000);
    MaterialFloat4 Local110 = lerp(MaterialFloat4(Local102.rgb,Local103.a),MaterialFloat4(Local104.rgb,Local105.a),MaterialFloat(Local109));
    MaterialFloat4 Local111 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local101.rg));
    MaterialFloat4 Local112 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local101.rg));
    MaterialFloat Local113 = abs(Local106.b);
    MaterialFloat Local114 = lerp((0.00000000 - 4.00000000),(4.00000000 + 1.00000000),Local113);
    MaterialFloat Local115 = (Local114 + -2.00000000);
    MaterialFloat Local116 = min(max(Local115,0.00000000),1.00000000);
    MaterialFloat4 Local117 = lerp(Local110,MaterialFloat4(Local111.rgb,Local112.a),MaterialFloat(Local116));
    MaterialFloat3 Local118 = lerp(Local117.rgb,MaterialFloat3(1.00000000,1.00000000,1.00000000),MaterialFloat(0.04000000));
    MaterialFloat3 Local119 = (Local118 * 2.00000000);
    MaterialFloat3 Local120 = (GetWorldPosition(Parameters) / Material.ScalarExpressions[1].y);
    MaterialFloat4 Local121 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local120.rb));
    MaterialFloat4 Local122 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local120.rb));
    MaterialFloat4 Local123 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local120.gb));
    MaterialFloat4 Local124 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local120.gb));
    MaterialFloat3 Local125 = mul(MaterialFloat3(0.00000000,0.00000000,1.00000000), (MaterialFloat3x3)(Parameters.TangentToWorld));
    MaterialFloat Local126 = abs(Local125.r);
    MaterialFloat Local127 = lerp((0.00000000 - 4.00000000),(4.00000000 + 1.00000000),Local126);
    MaterialFloat Local128 = min(max(Local127,0.00000000),1.00000000);
    MaterialFloat4 Local129 = lerp(MaterialFloat4(Local121.rgb,Local122.a),MaterialFloat4(Local123.rgb,Local124.a),MaterialFloat(Local128));
    MaterialFloat4 Local130 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local120.rg));
    MaterialFloat4 Local131 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local120.rg));
    MaterialFloat Local132 = abs(Local125.b);
    MaterialFloat Local133 = lerp((0.00000000 - 4.00000000),(4.00000000 + 1.00000000),Local132);
    MaterialFloat Local134 = (Local133 + -2.00000000);
    MaterialFloat Local135 = min(max(Local134,0.00000000),1.00000000);
    MaterialFloat4 Local136 = lerp(Local129,MaterialFloat4(Local130.rgb,Local131.a),MaterialFloat(Local135));
    MaterialFloat3 Local137 = lerp(Local136.rgb,MaterialFloat3(1.00000000,1.00000000,1.00000000),MaterialFloat(0.10000000));
    MaterialFloat3 Local138 = (Local119 * Local137);
    MaterialFloat3 Local139 = ResolvedView.WorldCameraOrigin;
    MaterialFloat3 Local140 = (GetWorldPosition(Parameters) - Local139);
    MaterialFloat Local141 = dot(Local140, Local140);
    MaterialFloat Local142 = sqrt(Local141);
    MaterialFloat Local143 = (Local142 / Material.ScalarExpressions[1].z);
    MaterialFloat Local144 = min(max(Local143,0.00000000),1.00000000);
    MaterialFloat3 Local145 = lerp(Local138,Local136.rgb,MaterialFloat(Local144));
    MaterialFloat Local146 = lerp(Material.ScalarExpressions[4].w,Material.ScalarExpressions[4].z,Local145.r);
    MaterialFloat Local147 = min(max(Local146,0.00000000),1.00000000);
    MaterialFloat Local148 = lerp(Local100,1.00000000,Local147);
    MaterialFloat3 Local149 = (Material.VectorExpressions[11].rgb * Local145);
    MaterialFloat3 Local150 = (Local148 * Local149);
    MaterialFloat3 Local151 = (GetWorldPosition(Parameters) / Material.ScalarExpressions[1].y);
    MaterialFloat4 Local152 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local151.rb));
    MaterialFloat4 Local153 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local151.rb));
    MaterialFloat4 Local154 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local151.gb));
    MaterialFloat4 Local155 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local151.gb));
    MaterialFloat3 Local156 = mul(MaterialFloat3(0.00000000,0.00000000,1.00000000), (MaterialFloat3x3)(Parameters.TangentToWorld));
    MaterialFloat Local157 = abs(Local156.r);
    MaterialFloat Local158 = lerp((0.00000000 - 4.00000000),(4.00000000 + 1.00000000),Local157);
    MaterialFloat Local159 = min(max(Local158,0.00000000),1.00000000);
    MaterialFloat4 Local160 = lerp(MaterialFloat4(Local152.rgb,Local153.a),MaterialFloat4(Local154.rgb,Local155.a),MaterialFloat(Local159));
    MaterialFloat4 Local161 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local151.rg));
    MaterialFloat4 Local162 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local151.rg));
    MaterialFloat Local163 = abs(Local156.b);
    MaterialFloat Local164 = lerp((0.00000000 - 4.00000000),(4.00000000 + 1.00000000),Local163);
    MaterialFloat Local165 = (Local164 + -2.00000000);
    MaterialFloat Local166 = min(max(Local165,0.00000000),1.00000000);
    MaterialFloat4 Local167 = lerp(Local160,MaterialFloat4(Local161.rgb,Local162.a),MaterialFloat(Local166));
    MaterialFloat3 Local168 = (GetWorldPosition(Parameters) / Material.ScalarExpressions[0].z);
    MaterialFloat4 Local169 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local168.rb));
    MaterialFloat4 Local170 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local168.rb));
    MaterialFloat4 Local171 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local168.gb));
    MaterialFloat4 Local172 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local168.gb));
    MaterialFloat3 Local173 = mul(MaterialFloat3(0.00000000,0.00000000,1.00000000), (MaterialFloat3x3)(Parameters.TangentToWorld));
    MaterialFloat Local174 = abs(Local173.r);
    MaterialFloat Local175 = lerp((0.00000000 - 4.00000000),(4.00000000 + 1.00000000),Local174);
    MaterialFloat Local176 = min(max(Local175,0.00000000),1.00000000);
    MaterialFloat4 Local177 = lerp(MaterialFloat4(Local169.rgb,Local170.a),MaterialFloat4(Local171.rgb,Local172.a),MaterialFloat(Local176));
    MaterialFloat4 Local178 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local168.rg));
    MaterialFloat4 Local179 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local168.rg));
    MaterialFloat Local180 = abs(Local173.b);
    MaterialFloat Local181 = lerp((0.00000000 - 4.00000000),(4.00000000 + 1.00000000),Local180);
    MaterialFloat Local182 = (Local181 + -2.00000000);
    MaterialFloat Local183 = min(max(Local182,0.00000000),1.00000000);
    MaterialFloat4 Local184 = lerp(Local177,MaterialFloat4(Local178.rgb,Local179.a),MaterialFloat(Local183));
    MaterialFloat Local185 = lerp(Local167.a,1.00000000,0.50000000);
    MaterialFloat Local186 = lerp(Local167.a,Local184.a,Local185);
    MaterialFloat Local187 = lerp(1.00000000,Local144,Material.ScalarExpressions[5].z);
    MaterialFloat Local188 = lerp(Local186,Local167.a,Local187);
    MaterialFloat Local189 = (MaterialFloat4(Local150,Local188).a - Material.ScalarExpressions[6].x);
    MaterialFloat Local190 = lerp(Material.ScalarExpressions[6].z,Material.ScalarExpressions[6].y,Local189);
    MaterialFloat Local191 = (Local96 + Local190);
    MaterialFloat Local192 = (Local191 * Material.ScalarExpressions[6].w);
    MaterialFloat Local193 = (min(max(((0.00000000 + (1.00000000 * 0.00000000)) * 1.50000000),0.00000000),1.00000000) * Local192);
    MaterialFloat Local194 = min(max(Local193,0.00000000),1.00000000);
    MaterialFloat3 Local195 = lerp(Local65,Local95,MaterialFloat(Local194));
    MaterialFloat3 Local196 = lerp(MaterialFloat3(0.00000000,0.00000000,1.00000000),MaterialFloat3(1.00000000,1.00000000,1.00000000),MaterialFloat(Material.ScalarExpressions[7].x));
    MaterialFloat Local197 = dot(Parameters.TexCoords[0].xy, MaterialFloat2(-0.00000000,1.00000000));
    MaterialFloat Local198 = dot(Parameters.TexCoords[0].xy, MaterialFloat2(1.00000000,0.00000000));
    MaterialFloat2 Local199 = (1.00000000 * MaterialFloat2(Local198,Local197));
    MaterialFloat2 Local200 = (Local199 + MaterialFloat2(0.00000000,0.00000000));
    MaterialFloat2 Local201 = (Local200 / Material.VectorExpressions[12].rg);
    MaterialFloat2 Local202 = (Local201 * Material.ScalarExpressions[7].z);
    MaterialFloat4 Local203 = UnpackNormalMap(Texture2DSample(Material.Texture2D_4,Material.Texture2D_4Sampler,Local202));
    MaterialFloat3 Local204 = (Local196 * Local203.rgb);
    MaterialFloat3 Local205 = lerp(MaterialFloat3(0.00000000,0.00000000,1.00000000),MaterialFloat3(1.00000000,1.00000000,1.00000000),MaterialFloat(Material.ScalarExpressions[7].w));
    MaterialFloat Local206 = dot(Parameters.TexCoords[0].xy, MaterialFloat2(-0.00000000,1.00000000));
    MaterialFloat Local207 = dot(Parameters.TexCoords[0].xy, MaterialFloat2(1.00000000,0.00000000));
    MaterialFloat2 Local208 = (1.00000000 * MaterialFloat2(Local207,Local206));
    MaterialFloat2 Local209 = (Local208 + MaterialFloat2(0.00000000,0.00000000));
    MaterialFloat2 Local210 = (Local209 / Material.VectorExpressions[13].rg);
    MaterialFloat2 Local211 = (Local210 * Material.ScalarExpressions[7].z);
    MaterialFloat4 Local212 = UnpackNormalMap(Texture2DSample(Material.Texture2D_4,Material.Texture2D_4Sampler,Local211));
    MaterialFloat3 Local213 = (Local205 * Local212.rgb);
    MaterialFloat3 Local214 = (Local213 * MaterialFloat3(1.00000000,1.00000000,0.00000000));
    MaterialFloat3 Local215 = (Local204 + Local214);
    MaterialFloat Local216 = dot(Local215, Local215);
    MaterialFloat Local217 = sqrt(Local216);
    MaterialFloat3 Local218 = (Local215 / Local217);
    MaterialFloat3 Local219 = ResolvedView.WorldCameraOrigin;
    MaterialFloat3 Local220 = (GetWorldPosition(Parameters) - Local219);
    MaterialFloat Local221 = dot(Local220, Local220);
    MaterialFloat Local222 = sqrt(Local221);
    MaterialFloat Local223 = (Local222 / Material.ScalarExpressions[1].z);
    MaterialFloat Local224 = min(max(Local223,0.00000000),1.00000000);
    MaterialFloat3 Local225 = lerp(Local218,Local213,MaterialFloat(Local224));
    MaterialFloat Local226 = lerp(0.00000000,-1.00000000,min(max(((0.00000000 + (1.00000000 * 0.00000000)) * 2.00000000),0.00000000),1.00000000));
    MaterialFloat Local227 = lerp(1.00000000,2.50000000,min(max(((0.00000000 + (1.00000000 * 0.00000000)) * 2.00000000),0.00000000),1.00000000));
    MaterialFloat Local228 = dot(Parameters.TexCoords[0].xy, MaterialFloat2(-0.00000000,1.00000000));
    MaterialFloat Local229 = dot(Parameters.TexCoords[0].xy, MaterialFloat2(1.00000000,0.00000000));
    MaterialFloat2 Local230 = (1.00000000 * MaterialFloat2(Local229,Local228));
    MaterialFloat2 Local231 = (Local230 + MaterialFloat2(0.00000000,0.00000000));
    MaterialFloat2 Local232 = (Local231 / Material.VectorExpressions[12].rg);
    MaterialFloat4 Local233 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_5,Material.Texture2D_5Sampler,Local232));
    MaterialFloat Local234 = dot(Parameters.TexCoords[0].xy, MaterialFloat2(-0.00000000,1.00000000));
    MaterialFloat Local235 = dot(Parameters.TexCoords[0].xy, MaterialFloat2(1.00000000,0.00000000));
    MaterialFloat2 Local236 = (1.00000000 * MaterialFloat2(Local235,Local234));
    MaterialFloat2 Local237 = (Local236 + MaterialFloat2(0.00000000,0.00000000));
    MaterialFloat2 Local238 = (Local237 / Material.VectorExpressions[13].rg);
    MaterialFloat4 Local239 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_5,Material.Texture2D_5Sampler,Local238));
    MaterialFloat3 Local240 = ResolvedView.WorldCameraOrigin;
    MaterialFloat3 Local241 = (GetWorldPosition(Parameters) - Local240);
    MaterialFloat Local242 = dot(Local241, Local241);
    MaterialFloat Local243 = sqrt(Local242);
    MaterialFloat Local244 = (Local243 / Material.ScalarExpressions[1].z);
    MaterialFloat Local245 = min(max(Local244,0.00000000),1.00000000);
    MaterialFloat3 Local246 = lerp(Local233.rgb,Local239.rgb,MaterialFloat(Local245));
    MaterialFloat3 Local247 = (Material.VectorExpressions[18].rgb * Local246);
    MaterialFloat3 Local248 = (1.00000000 * Local247);
    MaterialFloat2 Local249 = (Local238 * Material.ScalarExpressions[8].w);
    MaterialFloat4 Local250 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_6,Material.Texture2D_6Sampler,Local249));
    MaterialFloat2 Local251 = (Local232 * Material.ScalarExpressions[8].w);
    MaterialFloat4 Local252 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_6,Material.Texture2D_6Sampler,Local251));
    MaterialFloat Local253 = lerp(Local250.r,1.00000000,0.50000000);
    MaterialFloat Local254 = lerp(Local250.r,Local252.r,Local253);
    MaterialFloat Local255 = lerp(1.00000000,Local245,0.50000000);
    MaterialFloat Local256 = lerp(Local254,Local250.r,Local255);
    MaterialFloat Local257 = lerp(Local226,Local227,MaterialFloat4(Local248,Local256).a);
    MaterialFloat Local258 = lerp(Material.ScalarExpressions[9].y,Material.ScalarExpressions[9].x,(0.00000000 + (1.00000000 * 0.00000000)));
    MaterialFloat Local259 = (Local257 + Local258);
    MaterialFloat3 Local260 = mul(Local195, (MaterialFloat3x3)(Parameters.TangentToWorld));
    MaterialFloat Local261 = dot(Local260, Local260);
    MaterialFloat Local262 = sqrt(Local261);
    MaterialFloat3 Local263 = (Local260 / Local262);
    MaterialFloat Local264 = dot(Local263, Material.VectorExpressions[21].rgb);
    MaterialFloat Local265 = (Local264 * 0.50000000);
    MaterialFloat Local266 = (Local265 + 0.50000000);
    MaterialFloat Local267 = lerp(Material.ScalarExpressions[10].w,Material.ScalarExpressions[10].z,Local266);
    MaterialFloat Local268 = (Local259 + Local267);
    MaterialFloat Local269 = (Local268 - Material.ScalarExpressions[9].z);
    MaterialFloat Local270 = (Local269 * Material.ScalarExpressions[11].x);
    MaterialFloat Local271 = min(max(Local270,0.00000000),1.00000000);
    MaterialFloat3 Local272 = lerp(Local195,Local225,MaterialFloat(Local271));

    // The Normal is a special case as it might have its own expressions and also be used to calculate other inputs, so perform the assignment here
    PixelMaterialInputs.Normal = Local272;


    // Note that here MaterialNormal can be in world space or tangent space
    float3 MaterialNormal = GetMaterialNormal(Parameters, PixelMaterialInputs);

#if MATERIAL_TANGENTSPACENORMAL
#if SIMPLE_FORWARD_SHADING
    Parameters.WorldNormal = float3(0, 0, 1);
#endif

#if FEATURE_LEVEL >= FEATURE_LEVEL_SM4
    // ES2 will rely on only the final normalize for performance
    MaterialNormal = normalize(MaterialNormal);
#endif

    // normalizing after the tangent space to world space conversion improves quality with sheared bases (UV layout to WS causes shrearing)
    // use full precision normalize to avoid overflows
    Parameters.WorldNormal = TransformTangentNormalToWorld(Parameters, MaterialNormal);
#else //MATERIAL_TANGENTSPACENORMAL
    Parameters.WorldNormal = normalize(MaterialNormal);
#endif //MATERIAL_TANGENTSPACENORMAL

#if MATERIAL_TANGENTSPACENORMAL
    // flip the normal for backfaces being rendered with a two-sided material
    Parameters.WorldNormal *= Parameters.TwoSidedSign;
#endif

    Parameters.ReflectionVector = ReflectionAboutCustomWorldNormal(Parameters, Parameters.WorldNormal, false);

#if !PARTICLE_SPRITE_FACTORY
    Parameters.Particle.MotionBlurFade = 1.0f;
#endif // !PARTICLE_SPRITE_FACTORY

    // Now the rest of the inputs
    MaterialFloat Local273 = lerp(Local226,Local227,MaterialFloat4(Local248,Local256).a);
    MaterialFloat Local274 = lerp(Material.ScalarExpressions[9].y,Material.ScalarExpressions[9].x,(0.00000000 + (1.00000000 * 0.00000000)));
    MaterialFloat Local275 = (Local273 + Local274);
    MaterialFloat3 Local276 = mul(Local195, (MaterialFloat3x3)(Parameters.TangentToWorld));
    MaterialFloat Local277 = dot(Local276, Local276);
    MaterialFloat Local278 = sqrt(Local277);
    MaterialFloat3 Local279 = (Local276 / Local278);
    MaterialFloat Local280 = dot(Local279, Material.VectorExpressions[21].rgb);
    MaterialFloat Local281 = (Local280 * 0.50000000);
    MaterialFloat Local282 = (Local281 + 0.50000000);
    MaterialFloat Local283 = lerp(Material.ScalarExpressions[10].w,Material.ScalarExpressions[10].z,Local282);
    MaterialFloat Local284 = (Local275 + Local283);
    MaterialFloat Local285 = (Local284 - Material.ScalarExpressions[9].z);
    MaterialFloat Local286 = (Local285 * Material.ScalarExpressions[11].x);
    MaterialFloat Local287 = min(max(Local286,0.00000000),1.00000000);
    MaterialFloat3 Local288 = (Material.VectorExpressions[24].rgb * Local287);
    MaterialFloat3 Local289 = (Local288 + Material.VectorExpressions[25].rgb);
    MaterialFloat Local290 = dot(Parameters.TexCoords[0].xy, MaterialFloat2(-0.00000000,1.00000000));
    MaterialFloat Local291 = dot(Parameters.TexCoords[0].xy, MaterialFloat2(1.00000000,0.00000000));
    MaterialFloat2 Local292 = (1.00000000 * MaterialFloat2(Local291,Local290));
    MaterialFloat2 Local293 = (Local292 + MaterialFloat2(0.00000000,0.00000000));
    MaterialFloat2 Local294 = (Local293 / Material.VectorExpressions[1].rg);
    MaterialFloat4 Local295 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_7,Material.Texture2D_7Sampler,Local294));
    MaterialFloat Local296 = dot(Parameters.TexCoords[0].xy, MaterialFloat2(-0.00000000,1.00000000));
    MaterialFloat Local297 = dot(Parameters.TexCoords[0].xy, MaterialFloat2(1.00000000,0.00000000));
    MaterialFloat2 Local298 = (1.00000000 * MaterialFloat2(Local297,Local296));
    MaterialFloat2 Local299 = (Local298 + MaterialFloat2(0.00000000,0.00000000));
    MaterialFloat2 Local300 = (Local299 / Material.VectorExpressions[2].rg);
    MaterialFloat4 Local301 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_7,Material.Texture2D_7Sampler,Local300));
    MaterialFloat3 Local302 = ResolvedView.WorldCameraOrigin;
    MaterialFloat3 Local303 = (GetWorldPosition(Parameters) - Local302);
    MaterialFloat Local304 = dot(Local303, Local303);
    MaterialFloat Local305 = sqrt(Local304);
    MaterialFloat Local306 = (Local305 / Material.ScalarExpressions[1].z);
    MaterialFloat Local307 = min(max(Local306,0.00000000),1.00000000);
    MaterialFloat3 Local308 = lerp(Local295.rgb,Local301.rgb,MaterialFloat(Local307));
    MaterialFloat3 Local309 = (Material.VectorExpressions[30].rgb * Local308);
    MaterialFloat3 Local310 = (1.00000000 * Local309);
    MaterialFloat2 Local311 = (Local300 * Material.ScalarExpressions[12].x);
    MaterialFloat4 Local312 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_7,Material.Texture2D_7Sampler,Local311));
    MaterialFloat2 Local313 = (Local294 * Material.ScalarExpressions[12].x);
    MaterialFloat4 Local314 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_7,Material.Texture2D_7Sampler,Local313));
    MaterialFloat Local315 = lerp(Local312.a,1.00000000,0.50000000);
    MaterialFloat Local316 = lerp(Local312.a,Local314.a,Local315);
    MaterialFloat Local317 = lerp(1.00000000,Local307,Material.ScalarExpressions[12].y);
    MaterialFloat Local318 = lerp(Local316,Local312.a,Local317);
    MaterialFloat Local319 = lerp(Material.ScalarExpressions[3].y,Material.ScalarExpressions[3].x,(0.00000000 + (1.00000000 * 0.00000000)));
    MaterialFloat Local320 = (MaterialFloat4(Local150,Local188).a - Material.ScalarExpressions[6].x);
    MaterialFloat Local321 = lerp(Material.ScalarExpressions[6].z,Material.ScalarExpressions[6].y,Local320);
    MaterialFloat Local322 = (Local319 + Local321);
    MaterialFloat Local323 = (Local322 * Material.ScalarExpressions[6].w);
    MaterialFloat Local324 = (min(max(((0.00000000 + (1.00000000 * 0.00000000)) * 1.50000000),0.00000000),1.00000000) * Local323);
    MaterialFloat Local325 = min(max(Local324,0.00000000),1.00000000);
    MaterialFloat4 Local326 = lerp(MaterialFloat4(Local150,Local188),MaterialFloat4(Local310,Local318),MaterialFloat(Local325));
    MaterialFloat Local327 = (Material.ScalarExpressions[12].z + MaterialFloat4(Local310,Local318).a);
    MaterialFloat Local328 = lerp(MaterialFloat4(Local150,Local188).a,Local327,Local325);
    MaterialFloat Local329 = lerp(Local226,Local227,MaterialFloat4(Local248,Local256).a);
    MaterialFloat Local330 = lerp(Material.ScalarExpressions[9].y,Material.ScalarExpressions[9].x,(0.00000000 + (1.00000000 * 0.00000000)));
    MaterialFloat Local331 = (Local329 + Local330);
    MaterialFloat3 Local332 = mul(Local195, (MaterialFloat3x3)(Parameters.TangentToWorld));
    MaterialFloat Local333 = dot(Local332, Local332);
    MaterialFloat Local334 = sqrt(Local333);
    MaterialFloat3 Local335 = (Local332 / Local334);
    MaterialFloat Local336 = dot(Local335, Material.VectorExpressions[21].rgb);
    MaterialFloat Local337 = (Local336 * 0.50000000);
    MaterialFloat Local338 = (Local337 + 0.50000000);
    MaterialFloat Local339 = lerp(Material.ScalarExpressions[10].w,Material.ScalarExpressions[10].z,Local338);
    MaterialFloat Local340 = (Local331 + Local339);
    MaterialFloat Local341 = (Local340 - Material.ScalarExpressions[9].z);
    MaterialFloat Local342 = (Local341 * Material.ScalarExpressions[11].x);
    MaterialFloat Local343 = min(max(Local342,0.00000000),1.00000000);
    MaterialFloat4 Local344 = lerp(MaterialFloat4(Local326.rgb,Local328),MaterialFloat4(Local248,Local256),MaterialFloat(Local343));
    MaterialFloat Local345 = (GetWorldPosition(Parameters).r + GetWorldPosition(Parameters).g);
    MaterialFloat2 Local346 = (MaterialFloat2(Local345,GetWorldPosition(Parameters).b) / Material.VectorExpressions[6].rg);
    MaterialFloat4 Local347 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_2,Material.Texture2D_2Sampler,Local346));
    MaterialFloat Local348 = (Local347.r * Material.ScalarExpressions[4].y);
    MaterialFloat3 Local349 = (GetWorldPosition(Parameters) / Material.ScalarExpressions[0].z);
    MaterialFloat4 Local350 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local349.rb));
    MaterialFloat4 Local351 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local349.rb));
    MaterialFloat4 Local352 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local349.gb));
    MaterialFloat4 Local353 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local349.gb));
    MaterialFloat3 Local354 = mul(MaterialFloat3(0.00000000,0.00000000,1.00000000), (MaterialFloat3x3)(Parameters.TangentToWorld));
    MaterialFloat Local355 = abs(Local354.r);
    MaterialFloat Local356 = lerp((0.00000000 - 4.00000000),(4.00000000 + 1.00000000),Local355);
    MaterialFloat Local357 = min(max(Local356,0.00000000),1.00000000);
    MaterialFloat4 Local358 = lerp(MaterialFloat4(Local350.rgb,Local351.a),MaterialFloat4(Local352.rgb,Local353.a),MaterialFloat(Local357));
    MaterialFloat4 Local359 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local349.rg));
    MaterialFloat4 Local360 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local349.rg));
    MaterialFloat Local361 = abs(Local354.b);
    MaterialFloat Local362 = lerp((0.00000000 - 4.00000000),(4.00000000 + 1.00000000),Local361);
    MaterialFloat Local363 = (Local362 + -2.00000000);
    MaterialFloat Local364 = min(max(Local363,0.00000000),1.00000000);
    MaterialFloat4 Local365 = lerp(Local358,MaterialFloat4(Local359.rgb,Local360.a),MaterialFloat(Local364));
    MaterialFloat3 Local366 = lerp(Local365.rgb,MaterialFloat3(1.00000000,1.00000000,1.00000000),MaterialFloat(0.04000000));
    MaterialFloat3 Local367 = (Local366 * 2.00000000);
    MaterialFloat3 Local368 = (GetWorldPosition(Parameters) / Material.ScalarExpressions[1].y);
    MaterialFloat4 Local369 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local368.rb));
    MaterialFloat4 Local370 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local368.rb));
    MaterialFloat4 Local371 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local368.gb));
    MaterialFloat4 Local372 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local368.gb));
    MaterialFloat3 Local373 = mul(MaterialFloat3(0.00000000,0.00000000,1.00000000), (MaterialFloat3x3)(Parameters.TangentToWorld));
    MaterialFloat Local374 = abs(Local373.r);
    MaterialFloat Local375 = lerp((0.00000000 - 4.00000000),(4.00000000 + 1.00000000),Local374);
    MaterialFloat Local376 = min(max(Local375,0.00000000),1.00000000);
    MaterialFloat4 Local377 = lerp(MaterialFloat4(Local369.rgb,Local370.a),MaterialFloat4(Local371.rgb,Local372.a),MaterialFloat(Local376));
    MaterialFloat4 Local378 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local368.rg));
    MaterialFloat4 Local379 = ProcessMaterialColorTextureLookup(Texture2DSample(Material.Texture2D_3,Material.Texture2D_3Sampler,Local368.rg));
    MaterialFloat Local380 = abs(Local373.b);
    MaterialFloat Local381 = lerp((0.00000000 - 4.00000000),(4.00000000 + 1.00000000),Local380);
    MaterialFloat Local382 = (Local381 + -2.00000000);
    MaterialFloat Local383 = min(max(Local382,0.00000000),1.00000000);
    MaterialFloat4 Local384 = lerp(Local377,MaterialFloat4(Local378.rgb,Local379.a),MaterialFloat(Local383));
    MaterialFloat3 Local385 = lerp(Local384.rgb,MaterialFloat3(1.00000000,1.00000000,1.00000000),MaterialFloat(0.10000000));
    MaterialFloat3 Local386 = (Local367 * Local385);
    MaterialFloat3 Local387 = ResolvedView.WorldCameraOrigin;
    MaterialFloat3 Local388 = (GetWorldPosition(Parameters) - Local387);
    MaterialFloat Local389 = dot(Local388, Local388);
    MaterialFloat Local390 = sqrt(Local389);
    MaterialFloat Local391 = (Local390 / Material.ScalarExpressions[1].z);
    MaterialFloat Local392 = min(max(Local391,0.00000000),1.00000000);
    MaterialFloat3 Local393 = lerp(Local386,Local384.rgb,MaterialFloat(Local392));
    MaterialFloat Local394 = lerp(Material.ScalarExpressions[4].w,Material.ScalarExpressions[4].z,Local393.r);
    MaterialFloat Local395 = min(max(Local394,0.00000000),1.00000000);
    MaterialFloat Local396 = lerp(Local348,1.00000000,Local395);
    MaterialFloat3 Local397 = (Material.VectorExpressions[11].rgb * Local393);
    MaterialFloat3 Local398 = (Local396 * Local397);
    MaterialFloat3 Local399 = (Local398 * Local398);
    MaterialFloat3 Local400 = (Material.VectorExpressions[33].rgb * Local399);
    MaterialFloat Local401 = lerp(Material.ScalarExpressions[3].y,Material.ScalarExpressions[3].x,(0.00000000 + (1.00000000 * 0.00000000)));
    MaterialFloat Local402 = (MaterialFloat4(Local150,Local188).a - Material.ScalarExpressions[6].x);
    MaterialFloat Local403 = lerp(Material.ScalarExpressions[6].z,Material.ScalarExpressions[6].y,Local402);
    MaterialFloat Local404 = (Local401 + Local403);
    MaterialFloat Local405 = (Local404 * Material.ScalarExpressions[6].w);
    MaterialFloat Local406 = (min(max(((0.00000000 + (1.00000000 * 0.00000000)) * 1.50000000),0.00000000),1.00000000) * Local405);
    MaterialFloat Local407 = min(max(Local406,0.00000000),1.00000000);
    MaterialFloat3 Local408 = lerp(Local400,MaterialFloat3(0.00000000,0.00000000,0.00000000),MaterialFloat(Local407));
    MaterialFloat3 Local409 = lerp(Local408,Material.VectorExpressions[36].rgb,MaterialFloat(Local287));
    MaterialFloat3 Local410 = (Local409 * 0.34999999);
    MaterialFloat Local411 = lerp(Local226,Local227,MaterialFloat4(Local248,Local256).a);
    MaterialFloat Local412 = lerp(Material.ScalarExpressions[9].y,Material.ScalarExpressions[9].x,(0.00000000 + (1.00000000 * 0.00000000)));
    MaterialFloat Local413 = (Local411 + Local412);
    MaterialFloat3 Local414 = mul(Local195, (MaterialFloat3x3)(Parameters.TangentToWorld));
    MaterialFloat Local415 = dot(Local414, Local414);
    MaterialFloat Local416 = sqrt(Local415);
    MaterialFloat3 Local417 = (Local414 / Local416);
    MaterialFloat Local418 = dot(Local417, Material.VectorExpressions[21].rgb);
    MaterialFloat Local419 = (Local418 * 0.50000000);
    MaterialFloat Local420 = (Local419 + 0.50000000);
    MaterialFloat Local421 = lerp(Material.ScalarExpressions[10].w,Material.ScalarExpressions[10].z,Local420);
    MaterialFloat Local422 = (Local413 + Local421);
    MaterialFloat Local423 = (Local422 - Material.ScalarExpressions[9].z);
    MaterialFloat Local424 = (Local423 * Material.ScalarExpressions[11].x);
    MaterialFloat Local425 = min(max(Local424,0.00000000),1.00000000);
    MaterialFloat4 Local426 = lerp(MaterialFloat4(Local326.rgb,Local328),MaterialFloat4(Local248,Local256),MaterialFloat(Local425));
    MaterialFloat Local427 = (0.00000000 * Local425);
    MaterialFloat Local428 = (Local427 + MaterialFloat4(Local248,Local256).a);
    MaterialFloat Local429 = lerp(MaterialFloat4(Local326.rgb,Local328).a,Local428,Local425);
    MaterialFloat Local430 = lerp(Material.ScalarExpressions[13].z,Material.ScalarExpressions[13].y,MaterialFloat4(Local426.rgb,Local429).a);

    PixelMaterialInputs.EmissiveColor = Local289;
    PixelMaterialInputs.Opacity = 1.00000000;
    PixelMaterialInputs.OpacityMask = 1.00000000;
    PixelMaterialInputs.BaseColor = Local344.rgb;
    PixelMaterialInputs.Metallic = 0.00000000;
    PixelMaterialInputs.Specular = Local410;
    PixelMaterialInputs.Roughness = Local430;
    PixelMaterialInputs.Subsurface = 0;
    PixelMaterialInputs.AmbientOcclusion = 1.00000000;
    PixelMaterialInputs.Refraction = 0;
    PixelMaterialInputs.PixelDepthOffset = 0.00000000;

}

// Programmatically set the line number after all the material inputs which have a variable number of line endings
// This allows shader error line numbers after this point to be the same regardless of which material is being compiled
#line 1633

void ClipLODTransition(float2 SvPosition, float DitherFactor)
{
    if (abs(DitherFactor) > .001)
    {
        float RandCos = cos(dot(floor(SvPosition.xy), float2(347.83451793,3343.28371963)));
        float RandomVal = frac(RandCos * 1000.0);
        half RetVal = (DitherFactor < 0.0) ?
            (DitherFactor + 1.0 > RandomVal) :
            (DitherFactor < RandomVal);
        clip(RetVal - .001);
    }
}

void ClipLODTransition(FMaterialPixelParameters Parameters, float DitherFactor)
{
    ClipLODTransition(Parameters.SvPosition.xy, DitherFactor);
}


#define REQUIRES_VF_ATTRIBUTES_FOR_CLIPPING (USE_INSTANCING && USE_DITHERED_LOD_TRANSITION)

#if USE_INSTANCING && USE_DITHERED_LOD_TRANSITION
void ClipLODTransition(FMaterialPixelParameters Parameters)
{
    ClipLODTransition(Parameters, Parameters.PerInstanceParams.w);
}
#elif USE_DITHERED_LOD_TRANSITION && !USE_STENCIL_LOD_DITHER
float NonInstancedDitherLODFactor;
void ClipLODTransition(FMaterialPixelParameters Parameters)
{
    if (NonInstancedDitherLODFactor != 0.0)
    {
        ClipLODTransition(Parameters, NonInstancedDitherLODFactor);
    }
}
void ClipLODTransition(float2 SvPosition)
{
    if (NonInstancedDitherLODFactor != 0.0)
    {
        ClipLODTransition(SvPosition, NonInstancedDitherLODFactor);
    }
}
#else
void ClipLODTransition(FMaterialPixelParameters Parameters)
{
}
void ClipLODTransition(float2 SvPosition)
{
}
#endif

void GetMaterialClippingShadowDepth(FMaterialPixelParameters Parameters, FPixelMaterialInputs PixelMaterialInputs)
{
    ClipLODTransition(Parameters);
    #if MATERIALBLENDING_MASKED
        clip(GetMaterialMask(PixelMaterialInputs));
    #elif TRANSLUCENT_SHADOW_WITH_MASKED_OPACITY
        clip(GetMaterialMaskedOpacity(PixelMaterialInputs));
    #elif MATERIALBLENDING_TRANSLUCENT
        clip(GetMaterialOpacity(PixelMaterialInputs) - 1.0f / 255.0f);
    #endif
}

void GetMaterialClippingVelocity(FMaterialPixelParameters Parameters, FPixelMaterialInputs PixelMaterialInputs)
{
    ClipLODTransition(Parameters);
    #if MATERIALBLENDING_MASKED && MATERIAL_DITHER_OPACITY_MASK
        clip(GetMaterialMaskInputRaw(PixelMaterialInputs) - 1.0f / 255.0f);
    #elif MATERIALBLENDING_MASKED
        clip(GetMaterialMask(PixelMaterialInputs)); 
    #elif MATERIALBLENDING_TRANSLUCENT
        clip(GetMaterialOpacity(PixelMaterialInputs) - 1.0f / 255.0f);
    #endif
}


void GetMaterialCoverageAndClipping(FMaterialPixelParameters Parameters, FPixelMaterialInputs PixelMaterialInputs)
{
    ClipLODTransition(Parameters);

#if MATERIALBLENDING_MASKED
    #if MATERIAL_DITHER_OPACITY_MASK
        /*
        5 value dither. Every value present in +
        012
        234
        401
        */
        float2 Pos = Parameters.SvPosition.xy;
        
        float2 DepthGrad = {
            ddx( Parameters.SvPosition.z ),
            ddy( Parameters.SvPosition.z )
        };
        //Pos = floor( Pos + DepthGrad * float2( 4093, 3571 ) );

        float Dither5 = frac( ( Pos.x + Pos.y * 2 - 1.5 + View.TemporalAAParams.x ) / 5 );
        float Noise = frac( dot( float2( 171.0, 231.0 ) / 71, Pos.xy ) );
        float Dither = ( Dither5 * 5 + Noise ) * (1.0 / 6.0);

        clip( GetMaterialMask(PixelMaterialInputs) + Dither - 0.5 );
    #else
        clip(GetMaterialMask(PixelMaterialInputs));
    #endif
#endif
}

#define MATERIALBLENDING_MASKED_USING_COVERAGE (FORWARD_SHADING && MATERIALBLENDING_MASKED && SUPPORTS_PIXEL_COVERAGE)
#if MATERIALBLENDING_MASKED_USING_COVERAGE

uint GetDerivativeCoverageFromMask(float MaterialMask)
{
    uint Coverage = 0x0;
    if (MaterialMask > 0.01) Coverage = 0x8;
    if (MaterialMask > 0.25) Coverage = 0x9;
    if (MaterialMask > 0.50) Coverage = 0xD;
    if (MaterialMask > 0.75) Coverage = 0xF;
    return Coverage;
}

// Returns the new pixel coverage according the material's mask and the current pixel's mask.
uint DiscardMaterialWithPixelCoverage(FMaterialPixelParameters MaterialParameters, FPixelMaterialInputs PixelMaterialInputs)
{
    ClipLODTransition(MaterialParameters);
    float OriginalMask = GetMaterialMaskInputRaw(PixelMaterialInputs);
    float MaskClip = GetMaterialOpacityMaskClipValue();

    if (View.NumSceneColorMSAASamples > 1)
    {
        float Mask = (OriginalMask - MaskClip) / (1.0 - MaskClip);
        uint CurrentPixelCoverage = GetDerivativeCoverageFromMask(Mask);
        // Discard pixel shader if all sample are masked to avoid computing other material inputs.
        clip(float(CurrentPixelCoverage) - 0.5);
        return CurrentPixelCoverage;
    }
    clip(OriginalMask - MaskClip);
    return 0xF;
}

#endif // MATERIALBLENDING_MASKED_USING_COVERAGE


    #define FrontFaceSemantic SV_IsFrontFace
    #define FIsFrontFace bool
    half GetFloatFacingSign(FIsFrontFace bIsFrontFace)
    {
        return bIsFrontFace ? +1 : -1;
    }

#if MATERIAL_TWOSIDED_SEPARATE_PASS
    #define OPTIONAL_IsFrontFace
    static const FIsFrontFace bIsFrontFace = 1;
#else
    #define OPTIONAL_IsFrontFace , in FIsFrontFace bIsFrontFace : FrontFaceSemantic
#endif

/** Initializes the subset of Parameters that was not set in GetMaterialPixelParameters. */
void CalcMaterialParametersEx(
    in out FMaterialPixelParameters Parameters,
    in out FPixelMaterialInputs PixelMaterialInputs,
    float4 SvPosition,
    float4 ScreenPosition,
    FIsFrontFace bIsFrontFace,
    float3 TranslatedWorldPosition,
    float3 TranslatedWorldPositionExcludingShaderOffsets)
{
    // Remove the pre view translation
    Parameters.WorldPosition_CamRelative = TranslatedWorldPosition.xyz;
    Parameters.AbsoluteWorldPosition = TranslatedWorldPosition.xyz - ResolvedView.PreViewTranslation.xyz;

    // If the material uses any non-offset world position expressions, calculate those parameters. If not, 
    // the variables will have been initialised to 0 earlier.
#if USE_WORLD_POSITION_EXCLUDING_SHADER_OFFSETS
    Parameters.WorldPosition_NoOffsets_CamRelative = TranslatedWorldPositionExcludingShaderOffsets;
    Parameters.WorldPosition_NoOffsets = TranslatedWorldPositionExcludingShaderOffsets - ResolvedView.PreViewTranslation.xyz;
#endif

    Parameters.SvPosition = SvPosition;
    Parameters.ScreenPosition = ScreenPosition;

#if COMPILER_GLSL_ES2 || COMPILER_GLSL_ES3_1
    // ES2 normalize isn't done accurately. This seems to fix it.
    // Originally this was normalize(normalize(TranslatedWorldPosition.xyz)) but tegra4 appears to optimize that out.
    Parameters.CameraVector = normalize(-0.01 * Parameters.WorldPosition_CamRelative.xyz);
#else
    // TranslatedWorldPosition is the world position translated to the camera position, which is just -CameraVector
    Parameters.CameraVector = normalize(-Parameters.WorldPosition_CamRelative.xyz);
#endif

    Parameters.LightVector = 0;

    Parameters.TwoSidedSign = 1.0f;

#if MATERIAL_TWOSIDED && HAS_PRIMITIVE_UNIFORM_BUFFER
    Parameters.TwoSidedSign *= View.CullingSign * Primitive.LocalToWorldDeterminantSign;

    #if !MATERIAL_TWOSIDED_SEPARATE_PASS
        Parameters.TwoSidedSign *= GetFloatFacingSign(bIsFrontFace);
    #endif
#endif

    // Now that we have all the pixel-related parameters setup, calculate the Material Input/Attributes and Normal
    CalcPixelMaterialInputs(Parameters, PixelMaterialInputs);
}

// convenience function to setup CalcMaterialParameters assuming we don't support TranslatedWorldPositionExcludingShaderOffsets
// @param SvPosition from SV_Position when rendering the view, for other projections e.g. shadowmaps this function cannot be used and you need to call CalcMaterialParametersEx()
void CalcMaterialParameters(
    in out FMaterialPixelParameters Parameters,
    in out FPixelMaterialInputs PixelMaterialInputs,
    float4 SvPosition,
    FIsFrontFace bIsFrontFace)
{
    float4 ScreenPosition = SvPositionToResolvedScreenPosition(SvPosition);
    float3 TranslatedWorldPosition = SvPositionToResolvedTranslatedWorld(SvPosition);

    CalcMaterialParametersEx(Parameters, PixelMaterialInputs, SvPosition, ScreenPosition, bIsFrontFace, TranslatedWorldPosition, TranslatedWorldPosition);
}

void CalcMaterialParametersPost(
    in out FMaterialPixelParameters Parameters,
    in out FPixelMaterialInputs PixelMaterialInputs,
    float4 SvPosition,
    FIsFrontFace bIsFrontFace)
{
    float4 ScreenPosition = SvPositionToScreenPosition(SvPosition);
    float3 TranslatedWorldPosition = SvPositionToTranslatedWorld(SvPosition);

    CalcMaterialParametersEx(Parameters, PixelMaterialInputs, SvPosition, ScreenPosition, bIsFrontFace, TranslatedWorldPosition, TranslatedWorldPosition);
}

/** Assemble the transform from tangent space into world space */
half3x3 AssembleTangentToWorld( half3 TangentToWorld0, half4 TangentToWorld2 )
{
    // Will not be orthonormal after interpolation. This perfectly matches xNormal.
    // Any mismatch with xNormal will cause distortions for baked normal maps.

    // Derive the third basis vector off of the other two.
    // Flip based on the determinant sign
    half3 TangentToWorld1 = cross(TangentToWorld2.xyz,TangentToWorld0) * TangentToWorld2.w;
    // Transform from tangent space to world space
    return half3x3(TangentToWorld0, TangentToWorld1, TangentToWorld2.xyz);
}

// Whether the material shader should output pixel depth offset
#define OUTPUT_PIXEL_DEPTH_OFFSET (WANT_PIXEL_DEPTH_OFFSET && (MATERIALBLENDING_SOLID || MATERIALBLENDING_MASKED) && !ES2_PROFILE)

// Whether to use the hidden d3d11 feature that supports depth writes with ZCull by only pushing into the screen
//@todo - use for other SM5 platforms
#define SUPPORTS_CONSERVATIVE_DEPTH_WRITES ((COMPILER_HLSL && FEATURE_LEVEL >= FEATURE_LEVEL_SM5) || (PS4_PROFILE) || (COMPILER_METAL && FEATURE_LEVEL >= FEATURE_LEVEL_SM5))
#define USE_CONSERVATIVE_DEPTH_WRITES (OUTPUT_PIXEL_DEPTH_OFFSET && SUPPORTS_CONSERVATIVE_DEPTH_WRITES) 

#if USE_CONSERVATIVE_DEPTH_WRITES

#if COMPILER_HLSL
    // Note: for some reason using SV_DepthLessEqual without these interpolation modifiers causes a compile error in d3d
    #define INPUT_POSITION_QUALIFIERS linear noperspective centroid
    // Use conservative depth output so we still get Z Cull.  Note, this is a reversed Z depth surface.
    #define DEPTH_WRITE_SEMANTIC SV_DepthLessEqual
#elif COMPILER_METAL
    #define INPUT_POSITION_QUALIFIERS linear centroid
    #define DEPTH_WRITE_SEMANTIC SV_DepthLessEqual
#elif PS4_PROFILE
    #define INPUT_POSITION_QUALIFIERS
    #define DEPTH_WRITE_SEMANTIC S_DEPTH_LE_OUTPUT
#else
    #error USE_CONSERVATIVE_DEPTH_WRITES enabled for unsupported platform
#endif

#else
    #define INPUT_POSITION_QUALIFIERS 
    #define DEPTH_WRITE_SEMANTIC SV_DEPTH
#endif

#if OUTPUT_PIXEL_DEPTH_OFFSET
    #define OPTIONAL_OutDepthConservative ,out float OutDepth : DEPTH_WRITE_SEMANTIC
    #define OPTIONAL_OutDepth ,out float OutDepth : SV_DEPTH
#else
    #define OPTIONAL_OutDepthConservative
    #define OPTIONAL_OutDepth
#endif

float ApplyPixelDepthOffsetToMaterialParameters(inout FMaterialPixelParameters MaterialParameters, FPixelMaterialInputs PixelMaterialInputs, out float OutDepth)
{
    // Can only push into the scene for conservative depth writes
    float PixelDepthOffset = max(GetMaterialPixelDepthOffset(PixelMaterialInputs), 0);

    // Update positions used for shading
    MaterialParameters.ScreenPosition.w += PixelDepthOffset;
    MaterialParameters.SvPosition.w = MaterialParameters.ScreenPosition.w;
    MaterialParameters.AbsoluteWorldPosition += MaterialParameters.CameraVector * PixelDepthOffset;

    OutDepth = MaterialParameters.ScreenPosition.z / MaterialParameters.ScreenPosition.w;

    return PixelDepthOffset;
}
